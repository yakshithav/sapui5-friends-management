"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPrompts = getPrompts;
const i18n_1 = require("../../i18n");
const change_utils_1 = require("../../base/change-utils");
const cf_1 = require("../../base/cf");
const project_input_validator_1 = require("@sap-ux/project-input-validator");
const oDataVersions = [
    { name: '2.0', value: '2.0' },
    { name: '4.0', value: '4.0' }
];
/**
 * Exucute generic validation for input.
 *
 * @param value The value to validate.
 * @returns {string | boolean} An error message if the value is an empty string, or true if it is not.
 */
function validatePromptInput(value) {
    const validators = [project_input_validator_1.validateEmptyString, project_input_validator_1.validateEmptySpaces, project_input_validator_1.validateSpecialChars];
    for (const validator of validators) {
        const validationResult = validator(value);
        if (typeof validationResult === 'string') {
            return validationResult;
        }
    }
    return true;
}
/**
 * Validates if a value has a customer prefix and is empty except for customer prefix.
 *
 * @param value The value to validate.
 * @param label The label of the prompt.
 * @returns {boolean | string} True if the value is valid, or an error message if validation fails.
 */
function validateCustomerValue(value, label) {
    if (!(0, project_input_validator_1.hasCustomerPrefix)(value)) {
        return (0, i18n_1.t)('validators.errorInputInvalidValuePrefix', {
            value: (0, i18n_1.t)(label),
            prefix: "customer." /* NamespacePrefix.CUSTOMER */
        });
    }
    if (!value.replace('customer.', '').length) {
        return (0, i18n_1.t)('validators.errorCustomerEmptyValue', {
            value: (0, i18n_1.t)(label),
            prefix: "customer." /* NamespacePrefix.CUSTOMER */
        });
    }
    return true;
}
/**
 * Validates a JSON string.
 *
 * @param value The JSON string to validate.
 * @returns {boolean | string} True if the JSON is valid, or an error message if validation fails.
 */
function validatePromptJSON(value) {
    const validationResult = (0, project_input_validator_1.validateEmptyString)(value);
    if (typeof validationResult === 'string') {
        return true;
    }
    return (0, project_input_validator_1.validateJSON)(value);
}
/**
 * Validates the OData Service name prompt.
 *
 * @param value The value to validate.
 * @param answers The answers object.
 * @param isCustomerBase Whether the validation is for customer usage.
 * @param changeFiles The list of existing change files to check against.
 * @returns {boolean | string} True if no duplication is found, or an error message if validation fails.
 */
function validatePromptODataName(value, answers, isCustomerBase, changeFiles) {
    let validationResult = validatePromptInput(value);
    if (typeof validationResult === 'string') {
        return validationResult;
    }
    if (isCustomerBase) {
        validationResult = validateCustomerValue(value, 'prompts.oDataServiceNameLabel');
        if (typeof validationResult === 'string') {
            return validationResult;
        }
    }
    if ((0, project_input_validator_1.hasContentDuplication)(value, 'dataSource', changeFiles)) {
        return (0, i18n_1.t)('validators.errorDuplicatedValueOData');
    }
    if (answers.addAnnotationMode && value === answers.dataSourceName) {
        return (0, i18n_1.t)('validators.errorDuplicateNamesOData');
    }
    return true;
}
/**
 * Validates the OData Annotation name prompt.
 *
 * @param value The value to validate.
 * @param answers The answers object.
 * @param isCustomerBase Whether the validation is for customer usage.
 * @param changeFiles The list of existing change files to check against.
 * @returns {boolean | string} True if no duplication is found, or an error message if validation fails.
 */
function validatePromptODataAnnotationsName(value, answers, isCustomerBase, changeFiles) {
    let validationResult = validatePromptInput(value);
    if (typeof validationResult === 'string') {
        return validationResult;
    }
    if (isCustomerBase) {
        validationResult = validateCustomerValue(value, 'prompts.oDataAnnotationDataSourceNameLabel');
        if (typeof validationResult === 'string') {
            return validationResult;
        }
    }
    if ((0, project_input_validator_1.hasContentDuplication)(value, 'dataSource', changeFiles)) {
        return (0, i18n_1.t)('validators.errorDuplicatedValueOData');
    }
    if (value === answers.name) {
        return (0, i18n_1.t)('validators.errorDuplicateNamesOData');
    }
    return true;
}
/**
 * Validates the model name prompts.
 *
 * @param value The value to validate.
 * @param isCustomerBase Whether the validation is for customer usage.
 * @param changeFiles The list of existing change files to check against.
 * @returns {boolean | string} True if no duplication is found, or an error message if validation fails.
 */
function validatePromptModelName(value, isCustomerBase, changeFiles) {
    let validationResult = validatePromptInput(value);
    if (typeof validationResult === 'string') {
        return validationResult;
    }
    if (isCustomerBase) {
        validationResult = validateCustomerValue(value, 'prompts.oDataServiceModelNameLabel');
        if (typeof validationResult === 'string') {
            return validationResult;
        }
    }
    if ((0, project_input_validator_1.hasContentDuplication)(value, 'model', changeFiles)) {
        return (0, i18n_1.t)('validators.errorDuplicatedValueSapui5Model');
    }
    return true;
}
/**
 * Validates the OData Source URI prompt.
 *
 * @param value The value to validate.
 * @returns {boolean | string} True if the URI is valid, or an error message if validation fails.
 */
function validatePromptURI(value) {
    const validationResult = (0, project_input_validator_1.validateEmptyString)(value);
    if (typeof validationResult === 'string') {
        return validationResult;
    }
    if (!(0, project_input_validator_1.isDataSourceURI)(value)) {
        return (0, i18n_1.t)('validators.errorInvalidDataSourceURI');
    }
    return true;
}
/**
 * Gets the prompts for adding the new model.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {UI5FlexLayer} layer - UI5 Flex layer.
 * @returns {YUIQuestion<NewModelAnswers>[]} The questions/prompts.
 */
function getPrompts(projectPath, layer) {
    const isCustomerBase = "CUSTOMER_BASE" /* FlexLayer.CUSTOMER_BASE */ === layer;
    const defaultSeviceName = isCustomerBase ? "customer." /* NamespacePrefix.CUSTOMER */ : "" /* NamespacePrefix.EMPTY */;
    const isCFEnv = (0, cf_1.isCFEnvironment)(projectPath);
    const changeFiles = (0, change_utils_1.getChangesByType)(projectPath, "appdescr_ui5_addNewModel" /* ChangeType.ADD_NEW_MODEL */, 'manifest');
    return [
        {
            type: 'input',
            name: 'name',
            message: (0, i18n_1.t)('prompts.oDataServiceNameLabel'),
            default: defaultSeviceName,
            store: false,
            validate: (value, answers) => {
                return validatePromptODataName(value, answers, isCustomerBase, changeFiles);
            },
            guiOptions: {
                mandatory: true,
                hint: (0, i18n_1.t)('prompts.oDataServiceNameTooltip')
            }
        },
        {
            type: 'input',
            name: 'uri',
            message: (0, i18n_1.t)('prompts.oDataServiceUriLabel'),
            guiOptions: {
                mandatory: true,
                hint: (0, i18n_1.t)('prompts.oDataServiceUriTooltip')
            },
            validate: validatePromptURI,
            store: false
        },
        {
            type: 'list',
            name: 'version',
            message: (0, i18n_1.t)('prompts.oDataServiceVersionLabel'),
            choices: oDataVersions,
            default: (answers) => {
                if (answers.uri?.startsWith(isCFEnv ? '/odata/v4/' : '/sap/opu/odata4/')) {
                    return oDataVersions[1].value;
                }
                return oDataVersions[0].value;
            },
            store: false,
            validate: project_input_validator_1.validateEmptyString,
            guiOptions: {
                mandatory: true,
                hint: (0, i18n_1.t)('prompts.oDataServiceVersionTooltip'),
                applyDefaultWhenDirty: true
            }
        },
        {
            type: 'input',
            name: 'modelName',
            message: (0, i18n_1.t)('prompts.oDataServiceModelNameLabel'),
            guiOptions: {
                mandatory: true,
                hint: (0, i18n_1.t)('prompts.oDataServiceModelNameTooltip')
            },
            default: defaultSeviceName,
            validate: (value) => {
                return validatePromptModelName(value, isCustomerBase, changeFiles);
            },
            store: false
        },
        {
            type: 'editor',
            name: 'modelSettings',
            message: (0, i18n_1.t)('prompts.oDataServiceModelSettingsLabel'),
            store: false,
            validate: validatePromptJSON,
            guiOptions: {
                hint: (0, i18n_1.t)('prompts.oDataServiceModelSettingsTooltip')
            }
        },
        {
            type: 'confirm',
            name: 'addAnnotationMode',
            message: 'Do you want to add annotation?',
            default: false
        },
        {
            type: 'input',
            name: 'dataSourceName',
            message: (0, i18n_1.t)('prompts.oDataAnnotationDataSourceNameLabel'),
            validate: (value, answers) => {
                return validatePromptODataAnnotationsName(value, answers, isCustomerBase, changeFiles);
            },
            default: defaultSeviceName,
            store: false,
            guiOptions: {
                mandatory: true,
                hint: (0, i18n_1.t)('prompts.oDataAnnotationDataSourceNameTooltip')
            },
            when: (answers) => answers.addAnnotationMode
        },
        {
            type: 'input',
            name: 'dataSourceURI',
            message: (0, i18n_1.t)('prompts.oDataAnnotationDataSourceUriLabel'),
            validate: validatePromptURI,
            store: false,
            guiOptions: {
                mandatory: true,
                hint: (0, i18n_1.t)('prompts.oDataAnnotationDataSourceUriTooltip')
            },
            when: (answers) => answers.addAnnotationMode
        },
        {
            type: 'editor',
            name: 'annotationSettings',
            message: (0, i18n_1.t)('prompts.oDataAnnotationSettingsLabel'),
            validate: validatePromptJSON,
            store: false,
            guiOptions: {
                hint: (0, i18n_1.t)('prompts.oDataAnnotationSettingsTooltip')
            },
            when: (answers) => answers.addAnnotationMode
        }
    ];
}
//# sourceMappingURL=index.js.map