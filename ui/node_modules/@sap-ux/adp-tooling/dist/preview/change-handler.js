"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moduleNameContentMap = exports.fragmentTemplateDefinitions = void 0;
exports.tryFixChange = tryFixChange;
exports.isAddXMLChange = isAddXMLChange;
exports.isCodeExtChange = isCodeExtChange;
exports.isAddAnnotationChange = isAddAnnotationChange;
exports.isV4DescriptorChange = isV4DescriptorChange;
exports.addXmlFragment = addXmlFragment;
exports.addControllerExtension = addControllerExtension;
exports.addAnnotationFile = addAnnotationFile;
const path_1 = require("path");
const ejs_1 = require("ejs");
const crypto_1 = require("crypto");
const manifest_service_1 = require("../base/abap/manifest-service");
const helper_1 = require("../base/helper");
const odata_service_writer_1 = require("@sap-ux/odata-service-writer");
const editors_1 = require("../writer/editors");
const project_access_1 = require("@sap-ux/project-access");
const OBJECT_PAGE_CUSTOM_SECTION = 'OBJECT_PAGE_CUSTOM_SECTION';
const CUSTOM_ACTION = 'CUSTOM_ACTION';
const OBJECT_PAGE_HEADER_FIELD = 'OBJECT_PAGE_HEADER_FIELD';
const V2_SMART_TABLE_COLUMN = 'V2_SMART_TABLE_COLUMN';
const V2_SMART_TABLE_CELL = 'V2_SMART_TABLE_CELL';
const V4_MDC_TABLE_COLUMN = 'V4_MDC_TABLE_COLUMN';
const ANALYTICAL_TABLE_COLUMN = 'ANALYTICAL_TABLE_COLUMN';
const GRID_TREE_TABLE_COLUMN = 'GRID_TREE_TABLE_COLUMN';
const TABLE_ACTION = 'TABLE_ACTION';
exports.fragmentTemplateDefinitions = {
    [OBJECT_PAGE_CUSTOM_SECTION]: {
        path: 'common/op-custom-section.xml',
        getData: () => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            return {
                ids: {
                    objectPageSection: `op-section-${uuid}`,
                    objectPageSubSection: `op-subsection-${uuid}`,
                    hBox: `hbox-${uuid}`
                }
            };
        }
    },
    [CUSTOM_ACTION]: {
        path: 'common/custom-action.xml',
        getData: () => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            return {
                ids: {
                    toolbarActionButton: `btn-${uuid}`
                }
            };
        }
    },
    [TABLE_ACTION]: {
        path: 'common/v4-table-action.xml',
        getData: () => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            return {
                ids: {
                    customToolbarAction: `toolbarAction-${uuid}`,
                    customActionButton: `btn-${uuid}`
                }
            };
        }
    },
    [OBJECT_PAGE_HEADER_FIELD]: {
        path: 'common/header-field.xml',
        getData: () => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            return {
                ids: {
                    vBoxContainer: `vBox-${uuid}`,
                    label: `label-${uuid}`
                }
            };
        }
    },
    [V2_SMART_TABLE_COLUMN]: {
        path: 'v2/m-table-custom-column.xml',
        getData: (change) => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            const columnIndex = change.content.index;
            return {
                ids: {
                    column: `column-${uuid}`,
                    columnTitle: `column-title-${uuid}`,
                    customData: `custom-data-${uuid}`,
                    index: columnIndex.toFixed(0)
                }
            };
        }
    },
    [V2_SMART_TABLE_CELL]: {
        path: 'v2/m-table-custom-column-cell.xml',
        getData: () => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            return {
                ids: {
                    text: `cell-text-${uuid}`
                }
            };
        }
    },
    [V4_MDC_TABLE_COLUMN]: {
        path: 'v4/mdc-custom-column.xml',
        getData: () => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            return {
                ids: {
                    column: `column-${uuid}`,
                    text: `text-${uuid}`
                }
            };
        }
    },
    [GRID_TREE_TABLE_COLUMN]: {
        path: 'common/grid-tree-custom-column.xml',
        getData: (change) => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            const columnIndex = change.content.index;
            return {
                ids: {
                    column: `column-${uuid}`,
                    label: `label-${uuid}`,
                    text: `text-${uuid}`,
                    customData: `custom-data-${uuid}`,
                    index: columnIndex.toFixed(0)
                }
            };
        }
    },
    [ANALYTICAL_TABLE_COLUMN]: {
        path: 'common/analytical-custom-column.xml',
        getData: (change) => {
            const uuid = (0, crypto_1.randomBytes)(4).toString('hex');
            const columnIndex = change.content.index;
            return {
                ids: {
                    column: `column-${uuid}`,
                    label: `label-${uuid}`,
                    text: `text-${uuid}`,
                    customData: `custom-data-${uuid}`,
                    index: columnIndex.toFixed(0)
                }
            };
        }
    }
};
/**
 * A mapping object that defines how to extract change content data from changes based on their type.
 */
exports.moduleNameContentMap = {
    codeExt: (change) => (change.content?.codeRef ?? '').replace('.js', ''),
    addXML: (change) => change.content?.fragmentPath ?? ''
};
/**
 * Sets the moduleName property of the provided change to also support old changes with newer UI5 versions.
 *
 * @param change change to be fixed
 * @param logger logger instance
 */
/**
 * Attempts to fix a change object by setting its moduleName based on its reference and changeType
 * to also support old changes with newer UI5 versions.
 *
 * @param {CommonChangeProperties} change - The change object to be fixed.
 * @param {Logger} logger - An instance for logging warnings, errors, or informational messages.
 */
function tryFixChange(change, logger) {
    try {
        const prefix = change.reference.replace(/\./g, '/');
        change.moduleName = `${prefix}/changes/${exports.moduleNameContentMap[change.changeType](change)}`;
    }
    catch (error) {
        logger.warn('Could not fix missing module name.');
    }
}
/**
 * Determines whether a given change is of type `AddXMLChange`.
 *
 * @param {CommonChangeProperties} change - The change object to check.
 * @returns {boolean} `true` if the `changeType` is either 'addXML' or 'addXMLAtExtensionPoint',
 *          indicating the change is of type `AddXMLChange`.
 */
function isAddXMLChange(change) {
    return change.changeType === 'addXML' || change.changeType === 'addXMLAtExtensionPoint';
}
/**
 * Determines whether a given change is of type `codeExt`.
 *
 * @param {CommonChangeProperties} change - The change object to check.
 * @returns {boolean} `true` if the `changeType` is `codeExt`, indicating the change is of type `codeExtChange`.
 */
function isCodeExtChange(change) {
    return change.changeType === 'codeExt';
}
/**
 * Determines whether a given change is of type `AnnotationFileChange`.
 *
 * @param {CommonChangeProperties} change - The change object to check.
 * @returns {boolean} `true` if the `changeType` is either 'appdescr_app_addAnnotationsToOData',
 *          indicating the change is of type `AnnotationFileChange`.
 */
function isAddAnnotationChange(change) {
    return change.changeType === 'appdescr_app_addAnnotationsToOData';
}
/**
 * Determines whether a given change is of type `V4 Descriptor Change`.
 *
 * @param {CommonChangeProperties} change - The change object to check.
 * @returns {boolean} `true` if the `changeType` is either 'appdescr_fe_changePageConfiguration',
 *          indicating the change is of type `V4 Descriptor Change`.
 */
function isV4DescriptorChange(change) {
    return change.changeType === 'appdescr_fe_changePageConfiguration';
}
/**
 * Asynchronously adds an XML fragment to the project if it doesn't already exist.
 *
 * @param {string} basePath - The base path of the project.
 * @param {AddXMLChange} change - The change data, including the fragment path.
 * @param {Editor} fs - The mem-fs-editor instance.
 * @param {Logger} logger - The logging instance.
 * @param {CommonAdditionalChangeInfoProperties} additionalChangeInfo - Optional extended change properties.
 */
function addXmlFragment(basePath, change, fs, logger, additionalChangeInfo) {
    const { fragmentPath } = change.content;
    const fullPath = (0, path_1.join)(basePath, project_access_1.DirName.Changes, fragmentPath);
    const templateConfig = exports.fragmentTemplateDefinitions[additionalChangeInfo?.templateName ?? ''];
    try {
        if (templateConfig) {
            const fragmentTemplatePath = (0, path_1.join)(__dirname, '../../templates/rta', templateConfig.path);
            const text = fs.read(fragmentTemplatePath);
            const template = (0, ejs_1.render)(text, templateConfig.getData(change));
            fs.write(fullPath, template);
        }
        else {
            // copy default fragment template
            const templateName = 'fragment.xml'; /* TemplateFileName.Fragment */
            const fragmentTemplatePath = (0, path_1.join)(__dirname, '../../templates/rta', templateName);
            fs.copy(fragmentTemplatePath, fullPath);
        }
        logger.info(`XML Fragment "${fragmentPath}" was created`);
    }
    catch (error) {
        logger.error(`Failed to create XML Fragment "${fragmentPath}": ${error}`);
    }
}
/**
 * Asynchronously adds an controller extension to the project if it doesn't already exist.
 *
 * @param {string} rootPath - The root path of the project.
 * @param {string} basePath - The base path of the project.
 * @param {CodeExtChange} change - The change data, including the fragment path.
 * @param {Editor} fs - The mem-fs-editor instance.
 * @param {Logger} logger - The logging instance.
 */
async function addControllerExtension(rootPath, basePath, change, fs, logger) {
    const { codeRef } = change.content;
    const isTsSupported = (0, helper_1.isTypescriptSupported)(rootPath, fs);
    const fileName = (0, path_1.basename)(codeRef, '.js');
    const fullName = `${fileName}.${isTsSupported ? 'ts' : 'js'}`;
    const tmplFileName = isTsSupported ? "ts-controller.ejs" /* TemplateFileName.TSController */ : "controller.ejs" /* TemplateFileName.Controller */;
    const tmplPath = (0, path_1.join)(__dirname, '../../templates/rta', tmplFileName);
    try {
        const text = fs.read(tmplPath);
        const id = (await (0, helper_1.getVariant)(rootPath))?.id;
        const extensionPath = `${id}.${fileName}`;
        const templateData = isTsSupported ? { name: fileName, ns: id } : { extensionPath };
        const template = (0, ejs_1.render)(text, templateData);
        fs.write((0, path_1.join)(basePath, project_access_1.DirName.Changes, project_access_1.DirName.Coding, fullName), template);
    }
    catch (error) {
        logger.error(`Failed to create controller extension "${codeRef}": ${error}`);
        throw new Error(`Failed to create controller extension: ${error.message}`);
    }
}
/**
 * Asynchronously adds an XML fragment to the project if it doesn't already exist.
 *
 * @param {string} basePath - The base path of the project.
 * @param {string} projectRoot - The root path of the project.
 * @param {AnnotationFileChange} change - The change data, including the fragment path.
 * @param {Editor} fs - The mem-fs-editor instance.
 * @param {Logger} logger - The logging instance.
 *@param {AbapServiceProvider} provider - abap provider.
 */
async function addAnnotationFile(basePath, projectRoot, change, fs, logger, provider) {
    const { dataSourceId, annotations, dataSource } = change.content;
    const annotationDataSourceKey = annotations[0];
    const annotationUriSegments = dataSource[annotationDataSourceKey].uri.split('/');
    annotationUriSegments.shift();
    const fullPath = (0, path_1.join)(basePath, project_access_1.DirName.Changes, ...annotationUriSegments);
    try {
        const variant = await (0, helper_1.getVariant)(basePath);
        const manifestService = await manifest_service_1.ManifestService.initMergedManifest(provider, basePath, variant, logger);
        const metadata = await manifestService.getDataSourceMetadata(dataSourceId);
        const datasoruces = await manifestService.getManifestDataSources();
        const namespaces = (0, odata_service_writer_1.getAnnotationNamespaces)({ metadata });
        await (0, editors_1.generateChange)(projectRoot, "appdescr_app_addAnnotationsToOData" /* ChangeType.ADD_ANNOTATIONS_TO_ODATA */, {
            annotation: {
                dataSource: dataSourceId,
                namespaces,
                serviceUrl: datasoruces[dataSourceId].uri,
                fileName: (0, path_1.basename)(dataSource[annotationDataSourceKey].uri)
            },
            variant: await (0, helper_1.getVariant)(projectRoot),
            isCommand: false
        }, fs);
    }
    catch (error) {
        logger.error(`Failed to create Local Annotation File "${fullPath}": ${error}`);
        throw new Error('Failed to create Local Annotation File' + error.message);
    }
}
//# sourceMappingURL=change-handler.js.map