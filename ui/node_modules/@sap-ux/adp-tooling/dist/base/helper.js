"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariant = getVariant;
exports.updateVariant = updateVariant;
exports.flpConfigurationExists = flpConfigurationExists;
exports.isTypescriptSupported = isTypescriptSupported;
exports.getAdpConfig = getAdpConfig;
exports.getWebappFiles = getWebappFiles;
exports.filterAndMapInboundsToManifest = filterAndMapInboundsToManifest;
const fs_1 = require("fs");
const path_1 = require("path");
const project_access_1 = require("@sap-ux/project-access");
/**
 * Get the app descriptor variant.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @param {Editor} fs - The mem-fs editor instance.
 * @returns {Promise<DescriptorVariant>} The app descriptor variant.
 */
async function getVariant(basePath, fs) {
    const webappPath = await (0, project_access_1.getWebappPath)(basePath);
    if (fs) {
        return fs.readJSON((0, path_1.join)(webappPath, project_access_1.FileName.ManifestAppDescrVar));
    }
    return JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(webappPath, project_access_1.FileName.ManifestAppDescrVar), 'utf-8'));
}
/**
 * Writes the updated variant content to the manifest.appdescr_variant file.
 *
 * @param {string} basePath - The base path of the project.
 * @param {DescriptorVariant} variant - The descriptor variant object.
 * @param {Editor} fs - The mem-fs editor instance.
 */
async function updateVariant(basePath, variant, fs) {
    fs.writeJSON((0, path_1.join)(await (0, project_access_1.getWebappPath)(basePath), project_access_1.FileName.ManifestAppDescrVar), variant);
}
/**
 * Checks if FLP configuration changes exist in the manifest.appdescr_variant.
 *
 * This function determines whether there are changes of type `appdescr_app_changeInbound`
 * or `appdescr_app_addNewInbound` present in the content of the descriptor variant.
 *
 * @param {DescriptorVariant} variant - The descriptor variant object to check for FLP configuration changes.
 * @returns {Promise<boolean>} Returns `true` if FLP configuration changes exist, otherwise `false`.
 */
function flpConfigurationExists(variant) {
    return variant.content?.some(({ changeType }) => changeType === 'appdescr_app_changeInbound' || changeType === 'appdescr_app_addNewInbound');
}
/**
 * Checks whether TypeScript is supported in the project by verifying the existence of `tsconfig.json`.
 *
 * @param basePath - The base path of the project.
 * @param fs - An optional `mem-fs-editor` instance to check for the file's existence.
 * @returns `true` if `tsconfig.json` exists, otherwise `false`.
 */
function isTypescriptSupported(basePath, fs) {
    const path = (0, path_1.join)(basePath, 'tsconfig.json');
    return fs ? fs.exists(path) : (0, fs_1.existsSync)(path);
}
/**
 * Returns the adaptation project configuration, throws an error if not found.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @param {string} yamlPath - The path to yaml configuration file.
 * @returns {Promise<AdpPreviewConfig>} the adp configuration
 */
async function getAdpConfig(basePath, yamlPath) {
    const ui5ConfigPath = (0, path_1.isAbsolute)(yamlPath) ? yamlPath : (0, path_1.join)(basePath, yamlPath);
    let ui5Conf;
    let adp;
    try {
        ui5Conf = await (0, project_access_1.readUi5Yaml)((0, path_1.dirname)(ui5ConfigPath), (0, path_1.basename)(ui5ConfigPath));
        const customMiddleware = ui5Conf.findCustomMiddleware('fiori-tools-preview') ??
            ui5Conf.findCustomMiddleware('preview-middleware');
        adp = customMiddleware?.configuration?.adp;
    }
    catch (error) {
        // do nothing here
    }
    if (!adp) {
        throw new Error(`No system configuration found in ${(0, path_1.basename)(ui5ConfigPath)}`);
    }
    return adp;
}
/**
 * Get all files in the webapp folder.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @returns {Promise<{ relativePath: string; content: string }[]>} The files in the webapp folder.
 */
async function getWebappFiles(basePath) {
    const dir = await (0, project_access_1.getWebappPath)(basePath);
    const files = [];
    const getFilesRecursivelySync = (directory) => {
        const dirents = (0, fs_1.readdirSync)(directory, { withFileTypes: true });
        for (const dirent of dirents) {
            const fullPath = (0, path_1.join)(directory, dirent.name);
            if (dirent.isFile()) {
                const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
                const relativePath = (0, path_1.relative)(dir, fullPath);
                files.push({ relativePath, content });
            }
            else if (dirent.isDirectory()) {
                getFilesRecursivelySync(fullPath);
            }
        }
    };
    getFilesRecursivelySync(dir);
    return files;
}
/**
 * Transforms an array of inbound objects from the SystemInfo API format into a ManifestNamespace.Inbound object.
 *
 * @param {Inbound[]} inbounds - The array of inbound objects to transform.
 * @returns {ManifestNamespace.Inbound | undefined} The transformed inbounds or undefined if input is empty.
 */
function filterAndMapInboundsToManifest(inbounds) {
    if (!inbounds || inbounds.length === 0) {
        return undefined;
    }
    return inbounds.reduce((acc, inbound) => {
        // Skip if hideLauncher is not false
        if (!inbound?.content || inbound.content.hideLauncher !== false) {
            return acc;
        }
        const { semanticObject, action } = inbound.content;
        if (semanticObject && action) {
            const key = `${semanticObject}-${action}`;
            acc[key] = inbound.content;
        }
        return acc;
    }, {});
}
//# sourceMappingURL=helper.js.map