"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptGeneratorInput = promptGeneratorInput;
exports.promptTarget = promptTarget;
const uuid_1 = require("uuid");
const prompts_1 = __importDefault(require("prompts"));
const system_access_1 = require("@sap-ux/system-access");
const project_input_validator_1 = require("@sap-ux/project-input-validator");
const project_utils_1 = require("../writer/project-utils");
/**
 * Prompt the user for the required properties for an adaptation project.
 *
 * @param defaults optional default values for the prompts
 * @param logger optional logger instance
 * @returns a configuration for the adp writer
 */
async function promptGeneratorInput(defaults, logger) {
    defaults = defaults ?? {};
    const { target, apps, layer, customConfig } = await promptTarget(defaults, logger);
    const app = await (0, prompts_1.default)([
        {
            type: 'autocomplete',
            name: 'reference',
            message: 'Original application:',
            initial: defaults.reference,
            choices: apps.map((app) => ({
                title: `${app['sap.app/title']} (${(app['sap.fiori/registrationIds'] ?? []).join(',')})`,
                value: app['sap.app/id']
            })),
            suggest: (input, choices) => Promise.resolve(choices.filter((i) => i.title.includes(input)))
        },
        {
            type: 'text',
            name: 'id',
            message: (_prev) => {
                if (layer === 'CUSTOMER_BASE') {
                    return 'New adaptation id (prefix "customer" will be automatically added to the id):';
                }
                else {
                    return 'New adaptation id:';
                }
            },
            initial: defaults.id,
            format: (input) => {
                if (layer === 'CUSTOMER_BASE' && !input.startsWith('customer.')) {
                    return `customer.${input}`;
                }
                else {
                    return input;
                }
            },
            validate: (input) => input?.length > 0
        },
        {
            type: 'text',
            name: 'title',
            message: 'Application title:'
        }
    ]);
    const deploy = await (0, prompts_1.default)([
        {
            type: 'text',
            name: 'package',
            message: 'Deployment package:',
            initial: defaults.package ?? '$TMP',
            validate: (input) => input?.length > 0
        },
        {
            type: 'text',
            name: 'transport',
            message: 'Transport request (optional):',
            initial: defaults.transport
        }
    ]);
    const options = await (0, prompts_1.default)([
        {
            type: 'confirm',
            name: 'fioriTools',
            message: 'Enable Fiori tools?',
            initial: defaults.ft !== false,
            validate: (input) => input?.length > 0
        },
        {
            type: 'confirm',
            name: 'enableTypeScript',
            message: 'Enable TypeScript?',
            initial: defaults.ts !== false,
            validate: (input) => input?.length > 0
        }
    ]);
    return {
        app: {
            ...app,
            layer
        },
        target,
        options,
        deploy,
        customConfig
    };
}
/**
 * Prompt the user for the target system.
 *
 * @param defaults default values for the prompts
 * @param logger logger instance
 * @returns apps, layer, target url and client
 */
async function promptTarget(defaults, logger) {
    let count = 0;
    let target = { url: defaults.url, client: defaults.client };
    while (count < 3) {
        try {
            count++;
            target = await (0, prompts_1.default)([
                {
                    type: 'text',
                    name: 'url',
                    message: 'Target system url:',
                    initial: target.url,
                    validate: project_input_validator_1.validateEmptyString,
                    format: (input) => input.trim()
                },
                {
                    type: 'text',
                    name: 'client',
                    message: 'Client (optional):',
                    initial: target.client,
                    validate: project_input_validator_1.validateClient
                }
            ]);
            const systemInfo = await fetchSystemInformation(target, defaults.ignoreCertErrors, logger);
            return { target, ...systemInfo };
        }
        catch (error) {
            logger.error('Error while fetching system information. Please check your input.');
            logger.debug(error.message);
            if (error.code === 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY') {
                logger.error('If you are using a self-signed certificate, please use the --ignore-cert-errors flag.');
                const confirm = await (0, prompts_1.default)([
                    {
                        type: 'confirm',
                        name: 'ignoreCertErrors',
                        message: 'Do you want to ignore certificate errors?'
                    }
                ]);
                defaults.ignoreCertErrors = confirm.ignoreCertErrors;
            }
        }
    }
    throw new Error('Unable to fetch system information.');
}
/**
 * Fetches the system information from the target system.
 *
 * @param target target system
 * @param ignoreCertErrors ignore certificate errors
 * @param logger logger instance
 * @returns app index and layer
 */
async function fetchSystemInformation(target, ignoreCertErrors, logger) {
    const provider = await (0, system_access_1.createAbapServiceProvider)(target, {
        ignoreCertErrors
    }, true, logger);
    logger.info('Fetching system information...');
    const ato = await provider.getAtoInfo();
    const layer = ato.tenantType === 'SAP' ? "VENDOR" /* FlexLayer.VENDOR */ : "CUSTOMER_BASE" /* FlexLayer.CUSTOMER_BASE */;
    const packageJson = (0, project_utils_1.getPackageJSONInfo)();
    const customConfig = {
        adp: {
            environment: ato.operationsType ?? 'P',
            support: {
                id: packageJson.name ?? '',
                version: packageJson.version ?? '',
                toolsId: (0, uuid_1.v4)()
            }
        }
    };
    logger.info(`Target layer: ${layer}`);
    logger.info('Fetching list of available applications... (it can take a moment)');
    const appIndex = provider.getAppIndex();
    const searchParams = {
        'sap.ui/technology': 'UI5',
        'sap.app/type': 'application'
    };
    if (customConfig.adp.environment === 'C') {
        searchParams['sap.fiori/cloudDevAdaptationStatus'] = 'released';
    }
    const apps = await appIndex.search(searchParams, ['sap.app/id', 'sap.app/title', 'sap.fiori/registrationIds']);
    return { apps, layer, customConfig };
}
//# sourceMappingURL=prompt.js.map