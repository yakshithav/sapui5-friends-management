"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeAnnotationChange = writeAnnotationChange;
exports.writeChangeToFolder = writeChangeToFolder;
exports.writeChangeToFile = writeChangeToFile;
exports.parseStringToObject = parseStringToObject;
exports.getParsedPropertyValue = getParsedPropertyValue;
exports.getChangesByType = getChangesByType;
exports.findChangeWithInboundId = findChangeWithInboundId;
exports.getChange = getChange;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const project_access_1 = require("@sap-ux/project-access");
const types_1 = require("../types");
const ejs_1 = require("ejs");
/**
 * Writes annotation changes to the specified project path using the provided `mem-fs-editor` instance.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {number} timestamp - The timestamp of the change.
 * @param {AnnotationsData} annotation - The annotation data.
 * @param {ManifestChangeProperties} change - The annotation data change that will be written.
 * @param {Editor} fs - The `mem-fs-editor` instance used for file operations.
 * @returns {void}
 */
function writeAnnotationChange(projectPath, timestamp, annotation, change, fs) {
    try {
        const changesFolderPath = path_1.default.join(projectPath, project_access_1.DirName.Webapp, project_access_1.DirName.Changes);
        const annotationsFolderPath = path_1.default.join(changesFolderPath, project_access_1.DirName.Annotations);
        if (change) {
            const changeFileName = `${change.fileName}.change`;
            const changeFilePath = path_1.default.join(changesFolderPath, changeFileName);
            writeChangeToFile(changeFilePath, change, fs);
        }
        if (!annotation.filePath) {
            const annotationsTemplate = path_1.default.join(__dirname, '..', '..', 'templates', 'changes', "annotation.xml" /* TemplateFileName.Annotation */);
            const { namespaces, serviceUrl } = annotation;
            const schemaNamespace = `local_${timestamp}`;
            (0, ejs_1.renderFile)(annotationsTemplate, { namespaces, path: serviceUrl, schemaNamespace }, {}, (err, str) => {
                if (err) {
                    throw new Error('Error rendering template: ' + err.message);
                }
                fs.write(path_1.default.join(annotationsFolderPath, annotation.fileName ?? ''), str);
            });
        }
        else {
            const selectedDir = path_1.default.dirname(annotation.filePath);
            if (selectedDir !== annotationsFolderPath) {
                fs.copy(annotation.filePath, path_1.default.join(annotationsFolderPath, annotation.fileName ?? ''));
            }
        }
    }
    catch (e) {
        throw new Error(`Could not write annotation changes. Reason: ${e.message}`);
    }
}
/**
 * Writes a given change object to a file within a specified folder in the project's 'changes' directory.
 * If an additional subdirectory is specified, the change file is written there.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {ManifestChangeProperties} change - The change data to be written to the file.
 * @param {Editor} fs - The `mem-fs-editor` instance used for file operations.
 * @param {string} [dir] - An optional subdirectory within the 'changes' directory where the file will be written.
 * @returns {void}
 */
function writeChangeToFolder(projectPath, change, fs, dir = '') {
    try {
        let targetFolderPath = path_1.default.join(projectPath, project_access_1.DirName.Webapp, project_access_1.DirName.Changes);
        if (dir) {
            targetFolderPath = path_1.default.join(targetFolderPath, dir);
        }
        const fileName = `${change.fileName}.change`;
        const filePath = path_1.default.join(targetFolderPath, fileName);
        writeChangeToFile(filePath, change, fs);
    }
    catch (e) {
        throw new Error(`Could not write change to folder. Reason: ${e.message}`);
    }
}
/**
 * Writes a given change object to a specific file path. The change data is stringified to JSON format before
 * writing. This function is used to directly write changes to a file, without specifying a directory.
 *
 * @param {string} path - The root path of the project.
 * @param {ManifestChangeProperties} change - The change data to be written to the file.
 * @param {Editor} fs - The `mem-fs-editor` instance used for file operations.
 */
function writeChangeToFile(path, change, fs) {
    try {
        fs.writeJSON(path, change);
    }
    catch (e) {
        throw new Error(`Could not write change to file: ${path}. Reason: ${e.message}`);
    }
}
/**
 * Parses a string into an object.
 *
 * @param {string} str - The string to be parsed into an object. The string should be in the format of object properties without the surrounding braces.
 * @returns {{ [key: string]: string }} An object constructed from the input string.
 * @example
 * // returns { name: "value" }
 * parseStringToObject('"name":"value"');
 */
function parseStringToObject(str) {
    return JSON.parse(`{${str}}`);
}
/**
 * Attempts to parse a property value as JSON.
 *
 * @param {string} propertyValue - The property value to be parsed.
 * @returns {PropertyValueType} The parsed value if `propertyValue` is valid JSON; otherwise, returns the original `propertyValue`.
 * @example
 * // Returns the object { key: "value" }
 * getParsedPropertyValue('{"key": "value"}');
 *
 * // Returns the string "nonJSONValue" because it cannot be parsed as JSON
 * getParsedPropertyValue('nonJSONValue');
 */
function getParsedPropertyValue(propertyValue) {
    try {
        const value = JSON.parse(propertyValue);
        return value;
    }
    catch (e) {
        return propertyValue;
    }
}
/**
 * Retrieves all change files from a specified project path that match a given change type,
 * optionally within a specific subdirectory.
 *
 * @param {string} projectPath - The base path of the project.
 * @param {ChangeType} changeType - The type of changes to filter by, ensuring only changes of this type are returned.
 * @param {string} [subDir] - Optional subdirectory within the main changes directory.
 * @returns An array of change objects matching the specified change type.
 */
function getChangesByType(projectPath, changeType, subDir) {
    try {
        let targetDir = `${projectPath}/webapp/changes`;
        if (!(0, fs_1.existsSync)(targetDir)) {
            return [];
        }
        if (subDir) {
            targetDir = `${targetDir}/${subDir}`;
            if (!(0, fs_1.existsSync)(targetDir)) {
                return [];
            }
        }
        const fileNames = (0, fs_1.readdirSync)(targetDir, { withFileTypes: true })
            .filter((dirent) => dirent.isFile() && dirent.name.endsWith('.change'))
            .map((dirent) => dirent.name);
        if (fileNames.length === 0) {
            return [];
        }
        const changeFiles = fileNames
            .map((fileName) => {
            const filePath = path_1.default.resolve(targetDir, fileName);
            const fileContent = (0, fs_1.readFileSync)(filePath, 'utf-8');
            const change = JSON.parse(fileContent);
            return change;
        })
            .filter((changeFileObject) => changeFileObject.changeType === changeType);
        return changeFiles;
    }
    catch (e) {
        throw new Error(`Error reading change files: ${e.message}`);
    }
}
/**
 * Searches for a change file with a specific inbound ID within a project's change directory.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {string} inboundId - The inbound ID to search for within change files.
 * @returns {InboundChangeData} An object containing the file path and the change object with the matching inbound ID.
 * @throws {Error} Throws an error if the change file cannot be read or if there's an issue accessing the directory.
 */
function findChangeWithInboundId(projectPath, inboundId) {
    let changeObj;
    let filePath = '';
    const pathToInboundChangeFiles = path_1.default.join(projectPath, project_access_1.DirName.Webapp, project_access_1.DirName.Changes);
    if (!(0, fs_1.existsSync)(pathToInboundChangeFiles)) {
        return {
            filePath,
            changeWithInboundId: changeObj
        };
    }
    try {
        const files = (0, fs_1.readdirSync)(pathToInboundChangeFiles, { withFileTypes: true }).filter((dirent) => dirent.isFile() && dirent.name.includes('changeInbound'));
        for (const file of files) {
            const pathToFile = path_1.default.join(pathToInboundChangeFiles, file.name);
            const change = JSON.parse((0, fs_1.readFileSync)(pathToFile, 'utf-8'));
            if (change.content?.inboundId === inboundId) {
                changeObj = change;
                filePath = pathToFile;
                break;
            }
        }
        return {
            filePath,
            changeWithInboundId: changeObj
        };
    }
    catch (e) {
        throw new Error(`Could not find change with inbound id '${inboundId}'. Reason: ${e.message}`);
    }
}
/**
 * Constructs a generic change object based on provided parameters.
 *
 * @param {DescriptorVariant} variant - The app descriptor variant.
 * @param {number} timestamp - The timestamp.
 * @param {object} content - The content of the change to be applied.
 * @param {ChangeType} changeType - The type of the change.
 * @returns - An object representing the change
 */
function getChange({ id, layer, namespace }, timestamp, content, changeType) {
    const changeName = types_1.ChangeTypeMap[changeType];
    if (!changeName) {
        throw new Error(`Could not extract the change name from the change type: ${changeType}`);
    }
    const fileName = `id_${timestamp}_${changeName}`;
    return {
        fileName,
        namespace: path_1.default.posix.join(namespace, project_access_1.DirName.Changes),
        layer,
        fileType: 'change',
        creation: new Date(timestamp).toISOString(),
        packageName: '$TMP',
        reference: id,
        support: { generator: '@sap-ux/adp-tooling' },
        changeType,
        content
    };
}
//# sourceMappingURL=change-utils.js.map