"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryHelper = void 0;
const telemetry_1 = require("@sap-ux/telemetry");
const environment_1 = require("../environment");
const os_name_1 = __importDefault(require("os-name"));
const i18n_1 = require("../i18n");
/**
 * Helper class for intialising and preparing event data for telemetry.
 */
class TelemetryHelper {
    static _telemetryData;
    static _previousEventTimestamp;
    /**
     * Returns the telemetry data.
     *
     * @returns telemetry data
     */
    static get telemetryData() {
        return this._telemetryData;
    }
    /**
     * Load telemetry settings.
     *
     * @param options - tools suite telemetry init settings
     */
    static async initTelemetrySettings(options) {
        await (0, telemetry_1.initTelemetrySettings)(options);
    }
    /**
     * Creates telemetry data and adds default telemetry props.
     *
     * @param additionalData - set additional properties to be reported by telemetry
     * @param filterDups - filters duplicates by returning undefined if it's suspected to be a repeated event based on previous telemetry data & timestamp (1 second)
     * @returns telemetry data
     */
    static createTelemetryData(additionalData, filterDups = false) {
        const currentTimestamp = new Date().getTime();
        if (!this._previousEventTimestamp) {
            filterDups = false; // can't filter duplicates if no previous event timestamp
            this._previousEventTimestamp = currentTimestamp;
        }
        if (!this._telemetryData) {
            let osVersionName = (0, i18n_1.t)('telemetry.unknownOs');
            try {
                osVersionName = (0, os_name_1.default)();
            }
            catch {
                // no matched os name, possible beta or unreleased version
            }
            this._telemetryData = {
                Platform: (0, environment_1.getHostEnvironment)().technical,
                OperatingSystem: osVersionName
            };
        }
        if (filterDups) {
            const newTelemData = { ...this._telemetryData, ...additionalData };
            if (Math.abs(this._previousEventTimestamp - currentTimestamp) < 1000 &&
                JSON.stringify(newTelemData) === JSON.stringify(this._telemetryData)) {
                return undefined;
            }
        }
        this._previousEventTimestamp = currentTimestamp;
        this._telemetryData = Object.assign(this._telemetryData, additionalData);
        return this._telemetryData;
    }
    /**
     * Marks the start time. Example usage:
     * At the start of of the writing phase of the yeoman generator.
     * It should not be updated everytime calling createTelemetryData().
     */
    static markAppGenStartTime() {
        TelemetryHelper.createTelemetryData({
            markName: telemetry_1.PerformanceMeasurementAPI.startMark('LOADING_TIME')
        });
    }
    /**
     * Marks the end time. Example usage:
     * At the end of the writing phase of yeoman generator.
     */
    static markAppGenEndTime() {
        if (this._telemetryData?.markName) {
            telemetry_1.PerformanceMeasurementAPI.endMark(this._telemetryData.markName);
            telemetry_1.PerformanceMeasurementAPI.measure(this._telemetryData.markName);
        }
    }
}
exports.TelemetryHelper = TelemetryHelper;
//# sourceMappingURL=telemetryHelper.js.map