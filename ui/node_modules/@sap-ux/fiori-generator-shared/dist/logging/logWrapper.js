"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogWrapper = exports.DefaultLogger = exports.LOGGING_LEVEL_CONFIG_PROP = void 0;
exports.createCLILogger = createCLILogger;
const logger_1 = require("@vscode-logging/logger");
const logform_1 = require("logform");
const i18n_1 = require("../i18n");
exports.LOGGING_LEVEL_CONFIG_PROP = 'ApplicationWizard.loggingLevel';
/**
 * Empty Implementation of the Logger, this is not strictly necessary in app gen but
 * other modules consuming parts of app gen need a dummy implementation (logs to console)
 */
exports.DefaultLogger = {
    fatal: (msg) => {
        console.log(msg);
    },
    error: (msg) => {
        console.error(msg);
    },
    warn: (msg) => {
        console.warn(msg);
    },
    info: (msg) => {
        console.log(msg);
    },
    debug: (msg) => {
        console.log(msg);
    },
    trace: (msg) => {
        console.trace(msg);
    },
    getChildLogger: () => exports.DefaultLogger,
    getLogLevel: () => 'off',
    /**
     * Limited compatibility with `@sap-ux/logger`
     *
     * @param data
     */
    log: function (data) {
        console.log(data instanceof Object ? data.message : data);
    },
    add: function () {
        console.warn('Log method `add(transport)` not implemented.');
        return this;
    },
    remove: function () {
        console.warn('Log method `remove(transport)` not implemented.');
        return this;
    },
    transports: function () {
        console.warn('Logger method `transports()` not implemented.');
        return [];
    },
    child: function () {
        console.warn('Log method `remove(transport)` not implemented. Returning current logger.');
        return this;
    }
};
const LOG_LEVEL_KEYS = {
    off: -1,
    fatal: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
    trace: 5
};
/**
 * Creates a CLI logger based on the IChildLogger interface. This means we can use the
 * same log functions for extension and cli logging. No files generated for CLI use currently.
 *
 * @param logName - name of the logger
 * @param logLevel - defaults to off on cli
 * @returns {ILogWrapper} - the logger
 */
function createCLILogger(logName, logLevel = 'off') {
    const extensionLoggerOpts = {
        extName: logName,
        level: logLevel,
        logConsole: true
    };
    return (0, logger_1.getExtensionLogger)(extensionLoggerOpts);
}
/**
 * Log to vscode extension logger and yeoman logger simultaneously.
 * This allows use of Application Wizard log config and log file use but still have a single output channel for
 * generator logging.
 */
class LogWrapper {
    static _vscodeLogger;
    static _yoLogger;
    static _logLevel;
    static consoleFormat = logform_1.format.combine(logform_1.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }), logform_1.format.printf((msgJson) => {
        return `[${msgJson.timestamp}] ${msgJson.level.toUpperCase()}: ${msgJson.message}`;
    }));
    /**
     * Create a new LogWrapper instance.
     *
     * @param logName - name of the logger
     * @param yoLogger - yeoman logger
     * @param logLevel - log level
     * @param extLogger - vscode extension logger
     * @param vscode - vscode instance
     */
    constructor(logName, yoLogger, logLevel, extLogger, vscode) {
        LogWrapper._yoLogger = yoLogger;
        if (extLogger) {
            LogWrapper._logLevel = vscode
                ? vscode.workspace.getConfiguration().get(exports.LOGGING_LEVEL_CONFIG_PROP)
                : logLevel ?? 'info';
            LogWrapper._vscodeLogger = extLogger.getChildLogger({ label: logName });
        }
        else {
            if (!LogWrapper._yoLogger) {
                LogWrapper._vscodeLogger = createCLILogger(logName, logLevel);
            }
            LogWrapper._logLevel = logLevel === 'off' || !logLevel ? 'info' : logLevel;
        }
        LogWrapper._vscodeLogger?.debug((0, i18n_1.t)('debug.loggingConfigured', { logLevel: LogWrapper._logLevel }));
    }
    static logAtLevel = (level, message, ...args) => {
        if (typeof message === 'object') {
            message = JSON.stringify(message);
        }
        if (LogWrapper._vscodeLogger && level !== 'off') {
            LogWrapper._vscodeLogger[level](message, ...args);
        }
        if (LogWrapper._yoLogger) {
            if (LOG_LEVEL_KEYS[level] <= LOG_LEVEL_KEYS[LogWrapper._logLevel]) {
                LogWrapper._yoLogger(LogWrapper.consoleFormat.transform({
                    level,
                    message
                })[Symbol.for('message')]);
            }
        }
        else {
            exports.DefaultLogger.error((0, i18n_1.t)('error.logWrapperNotInitialised'));
        }
    };
    /**
     * Log a message at the fatal level.
     *
     * @param msg - message to log
     * @param {...any} args - additional arguments
     */
    fatal(msg, ...args) {
        LogWrapper.logAtLevel('fatal', msg, ...args);
    }
    /**
     * Log a message at the error level.
     *
     * @param msg - message to log
     * @param {...any} args - additional arguments
     */
    error(msg, ...args) {
        LogWrapper.logAtLevel('error', msg, ...args);
    }
    /**
     * Log a message at the warn level.
     *
     * @param msg - message to log
     * @param {...any} args - additional arguments
     */
    warn(msg, ...args) {
        LogWrapper.logAtLevel('warn', msg, ...args);
    }
    /**
     * Log a message at the info level.
     *
     * @param msg - message to log
     * @param {...any} args - additional arguments
     */
    info(msg, ...args) {
        LogWrapper.logAtLevel('info', msg, ...args);
    }
    /**
     * Log a message at the debug level.
     *
     * @param msg - message to log
     * @param {...any} args - additional arguments
     */
    debug(msg, ...args) {
        LogWrapper.logAtLevel('debug', msg, ...args);
    }
    /**
     * Log a message at the trace level.
     *
     * @param msg - message to log
     * @param {...any} args - additional arguments
     */
    trace(msg, ...args) {
        LogWrapper.logAtLevel('trace', msg, ...args);
    }
    /**
     * Log a message at the info level.
     *
     * @param msg - message to log
     */
    static log(msg) {
        LogWrapper.logAtLevel('info', msg);
    }
    /**
     * Get the currently configured log level.
     *
     * @returns {LogLevel} The current log level.
     */
    getLogLevel() {
        return LogWrapper._logLevel;
    }
    /**
     * Not implemented method, added to support limited interoperability with @sap-ux/logger.
     *
     * @returns {ILogWrapper} - the current logger
     */
    getChildLogger( /* opts: { label: string } */) {
        LogWrapper.logAtLevel(`trace`, 'Log method `getChildLogger()` not implemented. Returning current logger.');
        return this;
    }
    /**
     * Limited compatibility with `@sap-ux/logger` to use log() method.
     *
     * @param data
     */
    log(data) {
        // LogLevel is not supported in this implementation
        LogWrapper.logAtLevel('info', data.message ?? data);
    }
    /**
     * Not implemented method, added to support limited interoperability with @sap-ux/logger.
     *
     * @returns {ILogWrapper} - the current logger
     */
    add() {
        LogWrapper.logAtLevel(`warn`, 'Log method `add(transport)` not implemented.');
        return this;
    }
    /**
     * Not implemented method, added to support limited interoperability with @sap-ux/logger.
     *
     * @returns {ILogWrapper} - the current logger
     */
    remove() {
        LogWrapper.logAtLevel(`warn`, 'Log method `remove(transport)` not implemented.');
        return this;
    }
    /**
     * Added to support limited interoperability with @sap-ux/logger.
     *
     * @returns {ILogWrapper} - the current logger transports
     */
    transports() {
        LogWrapper.logAtLevel(`warn`, 'Log method `transports()` not implemented.');
        return [];
    }
    /**
     * Not implemented method, added to support limited interoperability with @sap-ux/logger.
     *
     * @returns {ILogWrapper} - the current logger
     */
    child() {
        LogWrapper.logAtLevel(`warn`, 'Log method `child(options)` not implemented. Returning current logger.');
        return this;
    }
}
exports.LogWrapper = LogWrapper;
//# sourceMappingURL=logWrapper.js.map