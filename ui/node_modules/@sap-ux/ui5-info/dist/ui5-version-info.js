"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUI5Versions = getUI5Versions;
exports.getLatestUI5Version = getLatestUI5Version;
const semver_1 = require("semver");
const commands_1 = require("./commands");
const axios_1 = __importDefault(require("axios"));
const logger_1 = require("@sap-ux/logger");
const ui5_version_fallback_1 = require("./ui5-version-fallback");
const constants_1 = require("./constants");
// Semantic version equivalent of 'Latest'
let latestUI5Version;
const passThroughStrings = new Set(['snapshot', 'snapshot-untested', constants_1.latestVersionString]);
const ui5VersionStrCmp = (a, b) => {
    const a1 = a.split('.');
    const b1 = b.split('.');
    const len = Math.max(a1.length, b1.length);
    for (let i = 0; i < len; i++) {
        const _a = +a1[i] || 0;
        const _b = +b1[i] || 0;
        if (_a === _b) {
            continue;
        }
        else {
            return _a > _b ? 1 : -1;
        }
    }
    return 0;
};
/**
 * Sorts UI5 version strings.
 *
 * @param ui5Versions - versions to be sorted
 * @returns sorted versions
 */
function sortUI5Versions(ui5Versions) {
    return ui5Versions.filter(Boolean).sort(ui5VersionStrCmp).reverse(); // Safety check to always ensure the list is sorted
}
/**
 * Sort function for snapshot versions.
 *
 * @param a - The first element for comparison.
 * @param b - The second element for comparison.
 * @returns 0, 1 or -1
 */
function snapshotSort(a, b) {
    a = a.replace('snapshot-', '');
    b = b.replace('snapshot-', '');
    const versions = [constants_1.defaultVersion, 'snapshot', 'untested'];
    // Sort 'Latest', 'snapshot' and 'snapshot-untested' in order
    if (versions.indexOf(a) > -1 && versions.indexOf(b) > -1) {
        return a.localeCompare(b);
    }
    // Sort 'Latest', 'snapshot' and 'snapshot-untested' to the top of the UI5 version list
    if (versions.indexOf(a) > -1 || versions.indexOf(b) > -1) {
        return ui5VersionStrCmp(a, b);
    }
    // Ensure snapshot is sorted to top of patch versions
    return ui5VersionStrCmp(b + '.999', a + '.999');
}
/**
 * Filters an array of versions and returns versions that are equal or higher minVersion.
 *
 * @param versions - array of versions
 * @param minVersion - minimum version to filter
 * @returns verions that match the minimum version criteria
 */
function filterNewerEqual(versions, minVersion) {
    return versions.filter((version) => {
        if (passThroughStrings.has(version)) {
            return true;
        }
        else if (version.startsWith('snapshot-')) {
            version = version.replace('snapshot-', '');
        }
        return ui5VersionStrCmp(version, minVersion) >= 0;
    });
}
/**
 * Makes a call to UI5 Versions APIs.
 *
 * @param host - if provided, the host name for the ui5 version request
 * @param pathname - if provided, an initial '/' followed by the path of the URL to UI5 version info
 * @returns ui5 versions in json format as defined by the generic type
 */
async function requestUI5Versions(host = constants_1.ui5VersionRequestInfo.OfficialUrl, pathname = `/${host === constants_1.ui5VersionRequestInfo.OfficialUrl
    ? constants_1.ui5VersionRequestInfo.VersionsFile
    : constants_1.ui5VersionRequestInfo.NeoAppFile}`) {
    const response = await axios_1.default.get(new URL(pathname, host).toString(), { responseType: 'json' });
    return response.data;
}
/**
 * Returns the list of UI5 version strings and metadata information for Major.Minor UI5 versions.
 *
 * @param url optional, url from which to request the UI5 versions
 * @returns ui5 version strings and metadata information
 */
async function parseUI5VersionsAndSupport(url = constants_1.ui5VersionRequestInfo.OfficialUrl.toString()) {
    const response = await requestUI5Versions(url);
    let versionStrings = [];
    const supportInfo = [];
    if (Array.isArray(response.routes)) {
        versionStrings = response.routes.map((route) => {
            if (route.path === '/') {
                latestUI5Version = route.target.version;
            }
            return route.path === '/' ? constants_1.defaultVersion : route.target.version;
        });
    }
    else {
        latestUI5Version = response['latest'].version;
        Object.values(response).forEach(({ version, support, patches = [] }) => {
            versionStrings.push(...patches);
            supportInfo.push({ version: version, support: support });
        });
    }
    return { versions: versionStrings, support: supportInfo };
}
/**
 * Returns ui5 versions from cache object.
 *
 * @param type 'officialVersions', 'snapshotsVersions or 'support'
 * @param useCache - true, use the cache if available, false, always make a network call to retrieve the latest UI5 versions
 * @param snapshotUrl - the url from which snapshot UI5 versions may be requested
 * @returns Array of UI5 versions or UI5VersionSupport objects
 */
const retrieveUI5VersionsCache = async (type, useCache = true, snapshotUrl) => {
    let versions = [];
    let support = [];
    // If the cache is empty populate it with the latest UI5 versions
    // Or, if `useCache` is false, then always make a network call to retrieve the latest UI5 versions
    if (constants_1.ui5VersionsCache[type].length === 0 || !useCache) {
        switch (type) {
            case "officialVersions" /* ui5VersionsType.official */:
            case "support" /* ui5VersionsType.support */:
                ({ versions, support } = await parseUI5VersionsAndSupport());
                constants_1.ui5VersionsCache.officialVersions = versions;
                constants_1.ui5VersionsCache.support = support;
                break;
            case "snapshotsVersions" /* ui5VersionsType.snapshot */:
                if (snapshotUrl) {
                    ({ versions } = await parseUI5VersionsAndSupport(snapshotUrl));
                    constants_1.ui5VersionsCache.snapshotsVersions = versions;
                }
                break;
            default:
        }
    }
    if (useCache) {
        return constants_1.ui5VersionsCache[type];
    }
    return type === "support" /* ui5VersionsType.support */ ? support : versions;
};
/**
 * Return a list of UI5 versions.
 *
 * @param filterOptions - see {@link UI5VersionFilterOptions}  def for filter options explantion
 * @param logger - logger
 * @returns UI5 version strings
 */
async function retrieveUI5Versions(filterOptions, logger = new logger_1.ToolsLogger()) {
    let officialVersions = [];
    let snapshotVersions = [];
    try {
        const minUI5Version = filterOptions?.minSupportedUI5Version ?? constants_1.defaultMinUi5Version;
        officialVersions = filterOptions?.onlyNpmVersion
            ? await retrieveNpmUI5Versions(filterOptions.ui5SelectedVersion, minUI5Version)
            : (await retrieveUI5VersionsCache("officialVersions" /* ui5VersionsType.official */, filterOptions?.useCache));
    }
    catch (error) {
        logger.warn(`Request to '${constants_1.ui5VersionRequestInfo.OfficialUrl}' failed. Error was: '${error.message}'. Fallback to default UI5 versions`);
        officialVersions = ui5_version_fallback_1.defaultUi5Versions.slice();
    }
    if (filterOptions?.snapshotVersionsHost) {
        try {
            snapshotVersions = (await retrieveUI5VersionsCache("snapshotsVersions" /* ui5VersionsType.snapshot */, filterOptions?.useCache, filterOptions?.snapshotVersionsHost));
        }
        catch (error) {
            logger.error(`Request to '${filterOptions.snapshotVersionsHost}' failed.  Error was: '${error.message}'`);
        }
    }
    let versions = [...officialVersions, ...snapshotVersions].sort(snapshotSort);
    // Dont return versions older than the default min version
    versions = filterNewerEqual(versions, filterOptions?.minSupportedUI5Version ?? constants_1.defaultMinUi5Version);
    if (filterOptions?.onlyVersionNumbers) {
        if (versions[0].toLocaleLowerCase().includes(constants_1.latestVersionString.toLocaleLowerCase())) {
            versions[0] = latestUI5Version;
        }
        versions = versions.filter((ele) => ele && /^\d+(\.\d+)*$/.test(ele));
    }
    if (filterOptions?.onlyLatestPatchVersion) {
        versions = retrieveLatestPatchVersions(versions);
    }
    // Remove duplicates, as they may be returned from some UI5 version APIs
    return [...new Set(versions)];
}
/**
 * Retrieve a list of versions filtered by latest patch version.
 *
 * @param versions - list of all versions
 * @returns list of latest patch versions
 */
function retrieveLatestPatchVersions(versions) {
    const latestPatchVersions = [];
    versions.forEach((version) => {
        const minorKey = `${(0, semver_1.major)(version)}.${(0, semver_1.minor)(version)}`;
        const latestPatchVersion = (0, semver_1.maxSatisfying)(versions, minorKey);
        if (latestPatchVersion && !latestPatchVersions.includes(latestPatchVersion)) {
            latestPatchVersions.push(latestPatchVersion);
        }
    });
    return latestPatchVersions;
}
/**
 * Retrieve a list of versions based on the odata version i.e. v2 | v4. If a known version is passed in and is a supported version, then only that version is returned.
 *
 * @param ui5SelectedVersion - selected version i.e. 1.80.0 | latest | ''
 * @param minUI5Version - the minimum ui5 version to return
 * @returns promise resolved with UI5 versions available from npm
 */
async function retrieveNpmUI5Versions(ui5SelectedVersion = undefined, minUI5Version) {
    const defaultMinVersion = minUI5Version ?? constants_1.defaultMinUi5Version;
    let results = [];
    try {
        results = await (0, commands_1.executeNpmUI5VersionsCmd)();
    }
    catch (e) {
        results = ui5_version_fallback_1.defaultUi5Versions.slice();
    }
    const sortedUI5Versions = sortUI5Versions(results);
    const versions = filterNewerEqual(sortedUI5Versions, defaultMinVersion);
    let latestVersions = versions.length
        ? versions.filter((ele) => ele && /^\d+(\.\d+)*$/.test(ele))
        : [defaultMinVersion];
    if (ui5SelectedVersion?.length) {
        const latestMinIdx = latestVersions.findIndex((v) => v === ui5SelectedVersion);
        if (latestMinIdx === -1) {
            if (ui5VersionStrCmp(ui5SelectedVersion, latestVersions.slice(-1)[0]) > 0 ||
                ui5SelectedVersion === constants_1.latestVersionString ||
                !(0, semver_1.valid)(ui5SelectedVersion)) {
                // Return latest supported version if selected version is not available yet or is 'Latest' or not valid
                latestVersions = latestVersions.slice(0);
            }
            else {
                // Return lowest supported version if selected version is lower
                latestVersions = latestVersions.slice(-1);
            }
        }
        else {
            // Return the selected version as the top item as its supported!
            latestVersions = latestVersions.slice(latestMinIdx);
        }
    }
    return latestVersions;
}
/**
 * Get the UI5 versions filtered by the specified options.
 *
 * @param filterOptions - filter the UI5 versions returned. See {@link UI5VersionFilterOptions} for more information.
 * @returns array of UI5 versions of type {@link UI5Version}.
 */
async function getUI5Versions(filterOptions) {
    let filteredUI5Versions;
    try {
        filteredUI5Versions = await retrieveUI5Versions(filterOptions);
    }
    catch (error) {
        new logger_1.ToolsLogger().warn(`Request to '${constants_1.ui5VersionRequestInfo.OfficialUrl}' failed. Error was: '${error.message}'. Fallback to default UI5 versions`);
        filteredUI5Versions = ui5_version_fallback_1.defaultUi5Versions.slice();
    }
    const defaultUI5Version = filteredUI5Versions[0];
    let ui5VersionsOverview;
    let finalDefaultUI5Version = defaultUI5Version;
    // Retrieve UI5 versions overview if maintained versions are to be included, note: overview and official versions are not the same
    if (filterOptions?.includeMaintained) {
        try {
            ui5VersionsOverview = (await retrieveUI5VersionsCache("support" /* ui5VersionsType.support */, filterOptions.useCache));
        }
        catch (error) {
            new logger_1.ToolsLogger().warn(`Request to '${constants_1.ui5VersionRequestInfo.OfficialUrl}' for supported info on UI5 versions failed. Error was: '${error.message}'. Fallback to default supported UI5 versions`);
            ui5VersionsOverview = ui5_version_fallback_1.supportedUi5VersionFallbacks;
        }
    }
    // Semantically filter the UI5 version, based on the support (maintained or not) and default version
    const isMaintained = (ui5) => ui5VersionsOverview?.some((v) => v &&
        `${(0, semver_1.major)(v.version)}.${(0, semver_1.minor)(v.version)}` === `${(0, semver_1.major)(ui5)}.${(0, semver_1.minor)(ui5)}` &&
        v.support === 'Maintenance') ?? false;
    // If the default version is not maintained, then fallback to the semantically latest maintained version
    if (filterOptions?.includeDefault && filterOptions.includeMaintained && !isMaintained(defaultUI5Version)) {
        const maintainedVersion = filteredUI5Versions.find(isMaintained);
        finalDefaultUI5Version = maintainedVersion ?? defaultUI5Version;
    }
    // Map the UI5 versions to the UI5Version type, respecting the filter options
    return filteredUI5Versions.map((ui5) => {
        const ui5Version = {
            version: ui5
        };
        if (filterOptions?.includeDefault) {
            ui5Version.default = ui5 === finalDefaultUI5Version;
        }
        if (filterOptions?.includeMaintained) {
            ui5Version.maintained = isMaintained(ui5);
        }
        return ui5Version;
    });
}
/**
 * Retrieves the latest supported published UI5 version.
 *
 * - If useCache is true, the function first attempts to retrieve the version from the cache:
 *    - If the cache contains official versions, the first version from the cache is returned.
 *    - If the cache is empty, the function makes an API call to fetch the latest UI5 versions & populates the cache back.
 * - If useCache is false, the function fetches the latest version from https://ui5.sap.com.
 * - If no versions are available (e.g., API call fails or cache is empty), the function returns the latest fallback version.
 *
 * @param {boolean} [useCache] - Whether to use cached versions.
 * @returns {Promise<string | undefined>} The latest supported UI5 version, or undefined if the API call fails.
 */
async function getLatestUI5Version(useCache = true) {
    const ui5Versions = await getUI5Versions({ useCache });
    return ui5Versions?.[0]?.version;
}
//# sourceMappingURL=ui5-version-info.js.map