"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateClient = validateClient;
exports.validateUrl = validateUrl;
exports.validateEmptyString = validateEmptyString;
exports.validateEmptySpaces = validateEmptySpaces;
exports.validateMaxLength = validateMaxLength;
exports.validateAllowedCharacters = validateAllowedCharacters;
exports.validateJSON = validateJSON;
exports.validateSpecialChars = validateSpecialChars;
exports.validateWindowsPathLength = validateWindowsPathLength;
const i18n_1 = require("../i18n");
/**
 * SAP client number is either empty or 3 digit string.
 *
 * @param client ABAP system client number
 * @returns true or error message
 */
function validateClient(client) {
    const formattedInput = client?.trim() || '';
    const isValid = formattedInput === '' || /^\d{3}$/.test(formattedInput);
    if (isValid) {
        return true;
    }
    else {
        return (0, i18n_1.t)('general.invalidClient', { client });
    }
}
/**
 * Validate url input is valid url format.
 *
 * @param input Backend ABAP system url
 * @returns true or error message
 */
function validateUrl(input) {
    try {
        const url = new URL(input);
        return !!url.protocol && !!url.host;
    }
    catch {
        return (0, i18n_1.t)('general.invalidUrl', { input });
    }
}
/**
 * Validate input is not empty string.
 *
 * @param input input string to be validated
 * @returns true or error message
 */
function validateEmptyString(input) {
    const formattedInput = input?.trim() || '';
    if (formattedInput.trim().length > 0) {
        return true;
    }
    return (0, i18n_1.t)('general.inputCannotBeEmpty');
}
/**
 * Validate input does not contain any whitespace characters.
 *
 * @param value The string to check for whitespace characters.
 * @returns true or error message
 */
function validateEmptySpaces(value) {
    if (/\s/.test(value)) {
        return (0, i18n_1.t)('general.inputCannotHaveSpaces');
    }
    return true;
}
/**
 * Validates that the given string does not exceed the specified maximum length.
 *
 * @param {string} value - The string value to validate.
 * @param {number} [maxLength] - The maximum allowed length of the string. If 0 or not provided, no length validation is performed.
 * @returns {boolean | string} Returns `true` if the validation passes, or an error message string if it fails.
 */
function validateMaxLength(value, maxLength = 0) {
    if (maxLength > 0 && value.length > maxLength) {
        return (0, i18n_1.t)('general.maxLength', { maxLength });
    }
    return true;
}
/**
 * Validates whether the input contains only alphanumeric characters and allowed special characters.
 *
 * @param {string} value - The input string to validate.
 * @param {string[]} allowedCharacters - An array of allowed special characters.
 * @returns {boolean | string} Returns `true` if validation passes, or an error message string if validation fails.
 */
function validateAllowedCharacters(value, allowedCharacters) {
    // Asterisks is supported for the semantic object and action field but not the inbound title
    if (allowedCharacters && allowedCharacters.length > 0) {
        const escapedChars = allowedCharacters.map((char) => `\\${char}`).join('');
        const regex = new RegExp(`^[a-zA-Z0-9${escapedChars}]+$`);
        if (!regex.test(value)) {
            return (0, i18n_1.t)('general.supportedFormats', {
                allowedCharacters: allowedCharacters.join('')
            });
        }
    }
    return true;
}
/**
 * Validate input is valid JSON.
 *
 * @param value The string to test.
 * @returns true or error message
 */
function validateJSON(value) {
    try {
        JSON.parse(`{${value}}`);
        return true;
    }
    catch {
        return (0, i18n_1.t)('general.invalidJSON');
    }
}
/**
 * Validates a value for special characters.
 *
 * @param value The value to validate.
 * @param regexp The regex expression for allowed special characters.
 * @returns {boolean} True if validation passes, or an error message if validation fails.
 */
function validateSpecialChars(value, regexp = '^[a-zA-Z0-9_$.\\-]+$') {
    const regex = new RegExp(regexp, 'g');
    if (regex.test(value)) {
        return true;
    }
    return (0, i18n_1.t)('general.invalidValueForSpecialChars');
}
/**
 * Checks if the combined Windows path length exceeds the default limit (256 characters).
 *
 * @param basePath The base path (e.g., target folder or mtaPath) + the name, ID, or additional segment to be appended
 * @param errorMessage The error message to be returned if the path is too long. Use `{length}` as a placeholder for the actual length.
 * @returns true if valid, or the error message if too long
 */
function validateWindowsPathLength(basePath, errorMessage) {
    if (process.platform === 'win32') {
        const combinedLength = `${basePath}`.length;
        if (combinedLength >= 256) {
            return errorMessage.replace('{{length}}', combinedLength.toString());
        }
    }
    return true;
}
//# sourceMappingURL=validators.js.map