"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateCdsFilesWithAnnotations = updateCdsFilesWithAnnotations;
exports.removeAnnotationsFromCDSFiles = removeAnnotationsFromCDSFiles;
exports.writeLocalServiceAnnotationXMLFiles = writeLocalServiceAnnotationXMLFiles;
exports.writeMetadata = writeMetadata;
exports.removeRemoteServiceAnnotationXmlFiles = removeRemoteServiceAnnotationXmlFiles;
exports.writeRemoteServiceAnnotationXmlFiles = writeRemoteServiceAnnotationXmlFiles;
exports.getAnnotationNamespaces = getAnnotationNamespaces;
const path_1 = require("path");
const fast_xml_parser_1 = require("fast-xml-parser");
const i18n_1 = require("../i18n");
const prettify_xml_1 = __importDefault(require("prettify-xml"));
const project_access_1 = require("@sap-ux/project-access");
/**
 * Updates the cds index or service file with the provided annotations.
 * This function takes an Editor instance and cds annotations
 * and updates either the index file or the service file with the given annotations.
 *
 * @param {Editor} fs - The memfs editor instance
 * @param {CdsAnnotationsInfo} annotations - The cds annotations info.
 * @returns {Promise<void>} A promise that resolves when the cds files have been updated.
 */
async function updateCdsIndexOrServiceFile(fs, annotations) {
    const dirPath = (0, path_1.join)(annotations.projectName, project_access_1.DirName.Annotations);
    const annotationPath = (0, path_1.normalize)(dirPath).split(/[\\/]/g).join(path_1.posix.sep);
    const annotationConfig = `\nusing from './${annotationPath}';`;
    // get index and service file paths
    const indexFilePath = (0, path_1.join)(annotations.projectPath, annotations.appPath ?? '', 'index.cds');
    const serviceFilePath = (0, path_1.join)(annotations.projectPath, annotations.appPath ?? '', 'services.cds');
    // extend index or service file with annotation config
    if (indexFilePath && fs.exists(indexFilePath)) {
        fs.append(indexFilePath, annotationConfig);
    }
    else if (fs.exists(serviceFilePath)) {
        fs.append(serviceFilePath, annotationConfig);
    }
    else {
        fs.write(serviceFilePath, annotationConfig);
    }
}
/**
 * Updates cds files with the provided annotations.
 * This function takes cds annotations and an Editor instance,
 * then updates the relevant cds files with the given annotations.
 *
 * @param {CdsAnnotationsInfo} annotations - The cds annotations info.
 * @param {Editor} fs - The memfs editor instance
 * @returns {Promise<void>} A promise that resolves when the cds files have been updated.
 */
async function updateCdsFilesWithAnnotations(annotations, fs) {
    if (Array.isArray(annotations)) {
        for (const annotationName in annotations) {
            const annotation = annotations[annotationName];
            const annotationCdsPath = (0, path_1.join)(annotation.projectPath, annotation.appPath ?? '', annotation.projectName, 'annotations.cds');
            // write into annotations.cds file
            if (fs.exists(annotationCdsPath)) {
                fs.append(annotationCdsPath, annotation.cdsFileContents);
            }
            else {
                fs.write(annotationCdsPath, annotation.cdsFileContents);
            }
            await updateCdsIndexOrServiceFile(fs, annotation);
        }
    }
    else {
        const annotationCdsPath = (0, path_1.join)(annotations.projectPath, annotations.appPath ?? '', annotations.projectName, 'annotations.cds');
        // write into annotations.cds file
        fs.write(annotationCdsPath, annotations.cdsFileContents);
        await updateCdsIndexOrServiceFile(fs, annotations);
    }
}
/**
 * Removes the cds index or service file with the provided annotations.
 * This function takes an Editor instance and cds annotations
 * and deletes either from the index file or the service file with the given annotations.
 *
 * @param {Editor} fs - The memfs editor instance
 * @param {CdsAnnotationsInfo} annotations - The cds annotations info.
 * @returns {Promise<void>} A promise that resolves when the cds files have been updated.
 */
async function removeCdsIndexOrServiceFile(fs, annotations) {
    const dirPath = (0, path_1.join)(annotations.projectName, project_access_1.DirName.Annotations);
    const annotationPath = (0, path_1.normalize)(dirPath).split(/[\\/]/g).join(path_1.posix.sep);
    const annotationConfig = `\nusing from './${annotationPath}';`;
    // Get index and service file paths
    const indexFilePath = (0, path_1.join)(annotations.projectPath, annotations.appPath ?? '', 'index.cds');
    const serviceFilePath = (0, path_1.join)(annotations.projectPath, annotations.appPath ?? '', 'services.cds');
    // Remove annotation config from index or service file
    if (indexFilePath && fs.exists(indexFilePath)) {
        // Read old annotations content and replace it with empty string
        const initialIndexContent = fs.read(indexFilePath);
        const updatedContent = initialIndexContent.replace(annotationConfig, '');
        fs.write(indexFilePath, updatedContent);
    }
    else if (fs.exists(serviceFilePath)) {
        // Read old annotations content and replace it with empty string
        const initialServiceFileContent = fs.read(serviceFilePath);
        const updatedContent = initialServiceFileContent.replace(annotationConfig, '');
        fs.write(serviceFilePath, updatedContent);
    }
}
/**
 * Removes annotations from CDS files.
 * This function takes cds annotations and an Editor instance,
 * then updates the relevant cds files with the given annotations.
 *
 * @param {CdsAnnotationsInfo} annotations - The cds annotations info.
 * @param {Editor} fs - The memfs editor instance
 * @returns {Promise<void>} A promise that resolves when the cds files have been updated.
 */
async function removeAnnotationsFromCDSFiles(annotations, fs) {
    if (Array.isArray(annotations)) {
        for (const annotationName in annotations) {
            const annotation = annotations[annotationName];
            const annotationCdsPath = (0, path_1.join)(annotation.projectPath, annotation.appPath ?? '', annotation.projectName, 'annotations.cds');
            // Remove from annotations.cds file
            if (fs.exists(annotationCdsPath)) {
                // Read old annotations content and replace it with empty string
                const initialCDSContent = fs.read(annotationCdsPath);
                const updatedContent = initialCDSContent.replace(annotation.cdsFileContents, '');
                fs.write(annotationCdsPath, updatedContent);
            }
            await removeCdsIndexOrServiceFile(fs, annotation);
        }
    }
    else {
        const annotationCdsPath = (0, path_1.join)(annotations.projectPath, annotations.appPath ?? '', annotations.projectName, 'annotations.cds');
        // Write into annotations.cds file
        if (fs.exists(annotationCdsPath)) {
            // Read old annotations content and replace it with empty string
            const initialCDSContent = fs.read(annotationCdsPath);
            const updatedContent = initialCDSContent.replace(annotations.cdsFileContents, '');
            fs.write(annotationCdsPath, updatedContent);
        }
        await removeCdsIndexOrServiceFile(fs, annotations);
    }
}
/**
 * Writes local copies of metadata.xml and local annotations.
 *
 * @param {Editor} fs - the memfs editor instance
 * @param {string} webappPath - the webapp path of an existing UI5 application
 * @param {string} templateRoot - path to the file templates
 * @param {OdataService} service - the OData service instance with EDMX type
 */
async function writeLocalServiceAnnotationXMLFiles(fs, webappPath, templateRoot, service) {
    // Write metadata.xml file
    await writeMetadata(fs, webappPath, service);
    // Adds local annotations to datasources section of manifest.json and writes the annotations file
    if (service.localAnnotationsName) {
        const namespaces = getAnnotationNamespaces(service);
        fs.copyTpl((0, path_1.join)(templateRoot, 'add', 'annotation.xml'), (0, path_1.join)(webappPath, project_access_1.DirName.Annotations, `${service.localAnnotationsName}.xml`), { ...service, namespaces });
    }
}
/**
 * Writes local copy of metadata.xml.
 *
 * @param {Editor} fs - the memfs editor instance
 * @param {string} webappPath - the webapp path of an existing UI5 application
 * @param {OdataService} service - the OData service instance with EDMX type
 */
async function writeMetadata(fs, webappPath, service) {
    if (service.metadata) {
        // mainService should be used in case there is no name defined for service
        fs.write((0, path_1.join)(webappPath, project_access_1.DirName.LocalService, service.name ?? 'mainService', 'metadata.xml'), (0, prettify_xml_1.default)(service.metadata, { indent: 4 }));
    }
}
/**
 * Removes annotation XML files for EDMX annotations.
 *
 * @param {Editor} fs - The memfs editor instance.
 * @param {string} basePath - The base path of the project.
 * @param {string} serviceName - Name of The OData service.
 * @param {OdataService} edmxAnnotations - The OData service annotations.
 */
async function removeRemoteServiceAnnotationXmlFiles(fs, basePath, serviceName, edmxAnnotations) {
    const webappPath = await (0, project_access_1.getWebappPath)(basePath, fs);
    // Write annotation xml if annotations are provided and service type is EDMX
    if (Array.isArray(edmxAnnotations)) {
        for (const annotationName in edmxAnnotations) {
            const annotation = edmxAnnotations[annotationName];
            const pathToAnnotationFile = (0, path_1.join)(webappPath, project_access_1.DirName.LocalService, serviceName, `${annotation.technicalName}.xml`);
            if (fs.exists(pathToAnnotationFile)) {
                fs.delete(pathToAnnotationFile);
            }
        }
    }
    else if (edmxAnnotations?.xml) {
        const pathToAnnotationFile = (0, path_1.join)(webappPath, project_access_1.DirName.LocalService, serviceName, `${edmxAnnotations.technicalName}.xml`);
        if (fs.exists(pathToAnnotationFile)) {
            fs.delete(pathToAnnotationFile);
        }
    }
}
/**
 * Writes annotation XML files for EDMX service annotations.
 *
 * @param {Editor} fs - The memfs editor instance.
 * @param {string} basePath - The base path of the project.
 * @param {string} serviceName - Name of The OData service.
 * @param {OdataService} edmxAnnotations - The OData service annotations.
 */
async function writeRemoteServiceAnnotationXmlFiles(fs, basePath, serviceName, edmxAnnotations) {
    const webappPath = await (0, project_access_1.getWebappPath)(basePath, fs);
    // Write annotation xml if annotations are provided and service type is EDMX
    if (Array.isArray(edmxAnnotations)) {
        for (const annotationName in edmxAnnotations) {
            const annotation = edmxAnnotations[annotationName];
            if (annotation?.xml) {
                fs.write((0, path_1.join)(webappPath, project_access_1.DirName.LocalService, serviceName, `${annotation.name}.xml`), (0, prettify_xml_1.default)(annotation.xml, { indent: 4 }));
            }
        }
    }
    else if (edmxAnnotations?.xml) {
        fs.write((0, path_1.join)(webappPath, project_access_1.DirName.LocalService, serviceName, `${edmxAnnotations.name}.xml`), (0, prettify_xml_1.default)(edmxAnnotations.xml, { indent: 4 }));
    }
}
/**
 * Returns the namespaces parsed from the specified metadata and single annotation.
 *
 * @param {EdmxAnnotationsInfo} edmxAnnotation - OData service annotations xml
 * @param {NamespaceAlias[]} schemaNamespaces - namespaces array from metadata
 * @returns A reference to the namspaces array
 */
function getAnnotationNamespacesForSingleAnnotation(edmxAnnotation, schemaNamespaces) {
    if (edmxAnnotation?.xml) {
        // Parse once
        const annotationsJson = xmlToJson(edmxAnnotation.xml);
        return schemaNamespaces.map((schema) => {
            // Check if alias exists in backend annotation file, if so use it
            const annotationAlias = edmxAnnotation.xml && schema.namespace ? getAliasFromAnnotation(annotationsJson, schema.namespace) : '';
            if (annotationAlias) {
                schema.alias = annotationAlias;
            }
            return schema;
        });
    }
    return schemaNamespaces;
}
/**
 * Returns the namespaces parsed from the specified metadata and annotations.
 *
 * @param {Partial<OdataService>} service - an odata service where at least metadata and annotations properties are defined
 * @param {string} service.metadata - OData service metadata xml
 * @param {string} service.annotations - OData service annotations xml
 * @returns A reference to the namspaces array
 */
function getAnnotationNamespaces({ metadata, annotations }) {
    // Enhance service with annotations namespaces
    let schemaNamespaces = metadata ? getNamespaces(metadata) : [];
    if (Array.isArray(annotations)) {
        for (const annotationName in annotations) {
            const edmxAnnotation = annotations[annotationName];
            schemaNamespaces = getAnnotationNamespacesForSingleAnnotation(edmxAnnotation, schemaNamespaces);
        }
    }
    else {
        const edmxAnnotation = annotations;
        schemaNamespaces = getAnnotationNamespacesForSingleAnnotation(edmxAnnotation, schemaNamespaces);
    }
    return schemaNamespaces;
}
/**
 * Convert specified xml string to JSON.
 *
 * @param xml - the schema to parse
 * @returns parsed object representation of passed XML
 */
function xmlToJson(xml) {
    const options = {
        attributeNamePrefix: '',
        ignoreAttributes: false,
        ignoreNameSpace: true,
        parseAttributeValue: true
    };
    try {
        const parser = new fast_xml_parser_1.XMLParser(options);
        return parser.parse(xml, true);
    }
    catch (error) {
        throw new Error((0, i18n_1.t)('error.unparseableXML', { error }));
    }
}
/**
 * Gets all the schema namespaces and their aliases from the provided metadata.
 *
 * @param metadata - odata service metadata
 * @returns Array of namespaces and their aliases
 */
function getNamespaces(metadata) {
    const jsonMetadata = xmlToJson(metadata);
    let schema = jsonMetadata['edmx:Edmx']?.['edmx:DataServices']?.['Schema'];
    if (!schema) {
        return [];
    }
    // Can be array or single item
    if (!Array.isArray(schema)) {
        schema = [schema];
    }
    return schema.map((item) => {
        return {
            namespace: item.Namespace,
            alias: item.Alias || ''
        };
    });
}
/**
 * Gets namespace aliases from the specified annotations xml.
 *
 * @param annotations - annotations definition as json
 * @param namespace - the namespace to search
 * @returns An alias for the specified namespace or empty string
 */
function getAliasFromAnnotation(annotations, namespace) {
    let references = annotations['edmx:Edmx']?.['edmx:Reference'];
    // Can be array or single item
    if (!Array.isArray(references)) {
        references = [references];
    }
    const annoNamespace = references.find((ref) => ref['edmx:Include']?.['Namespace'] === namespace && ref['edmx:Include']?.['Alias']);
    return annoNamespace ? annoNamespace['edmx:Include']?.['Alias'] : '';
}
//# sourceMappingURL=annotations.js.map