"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnnotationNamespaces = exports.ServiceType = exports.OdataVersion = void 0;
exports.generate = generate;
exports.update = update;
exports.remove = remove;
const path_1 = require("path");
const mem_fs_1 = require("mem-fs");
const mem_fs_editor_1 = require("mem-fs-editor");
const update_1 = require("./update");
const data_1 = require("./data");
Object.defineProperty(exports, "getAnnotationNamespaces", { enumerable: true, get: function () { return data_1.getAnnotationNamespaces; } });
const i18n_1 = require("./i18n");
const types_1 = require("./types");
Object.defineProperty(exports, "OdataVersion", { enumerable: true, get: function () { return types_1.OdataVersion; } });
Object.defineProperty(exports, "ServiceType", { enumerable: true, get: function () { return types_1.ServiceType; } });
const delete_1 = require("./delete");
const project_access_1 = require("@sap-ux/project-access");
const manifest_1 = require("./data/manifest");
/**
 * Ensures the existence of the given files in the provided base path. If a file in the provided list does not exit, an error would be thrown.
 *
 * @param basePath - the root path of an existing UI5 application
 * @param files - list of files that need to exist
 * @param fs - the memfs editor instance
 */
function ensureExists(basePath, files, fs) {
    files.forEach((path) => {
        if (!fs.exists((0, path_1.join)(basePath, path))) {
            throw new Error((0, i18n_1.t)('error.requiredProjectFileNotFound', { path }));
        }
    });
}
/**
 * Try finding a package.json and a ui5.yaml for the given project by looking upwards in the folder hierachy.
 *
 * @param {string} basePath - the root path of an existing UI5 application
 * @param {Editor} [fs] - the memfs editor instance
 * @returns an object with the optional locations of the package.json and ui5.yaml, ui5-local.yaml, ui5-mock.yaml
 */
async function findProjectFiles(basePath, fs) {
    const files = {};
    const parts = basePath.split(path_1.sep);
    while (parts.length > 0 && (!files.packageJson || !files.ui5Yaml || !files.ui5LocalYaml || !files.ui5MockYaml)) {
        const path = parts.join(path_1.sep);
        if (!files.packageJson && fs.exists((0, path_1.join)(path, 'package.json'))) {
            files.packageJson = (0, path_1.join)(path, 'package.json');
        }
        if (!files.ui5Yaml && fs.exists((0, path_1.join)(path, 'ui5.yaml'))) {
            files.ui5Yaml = (0, path_1.join)(path, 'ui5.yaml');
        }
        if (!files.ui5LocalYaml && fs.exists((0, path_1.join)(path, 'ui5-local.yaml'))) {
            files.ui5LocalYaml = (0, path_1.join)(path, 'ui5-local.yaml');
        }
        if (!files.ui5MockYaml && fs.exists((0, path_1.join)(path, 'ui5-mock.yaml'))) {
            files.ui5MockYaml = (0, path_1.join)(path, 'ui5-mock.yaml');
        }
        parts.pop();
    }
    return files;
}
/**
 * Writes the odata service related data and files to an existing UI5 project specified by the base path.
 *
 * @param {string} basePath - the root path of an existing UI5 application
 * @param {OdataService} service - the OData service instance
 * @param {Editor} [fs] - the memfs editor instance
 * @throws {Error} - if required UI5 project files are not found
 * @returns {Promise<Editor>} the updated memfs editor instance
 */
async function generate(basePath, service, fs) {
    if (!fs) {
        fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    }
    const paths = await findProjectFiles(basePath, fs);
    const webappPath = await (0, project_access_1.getWebappPath)(basePath, fs);
    ensureExists(webappPath, ['manifest.json'], fs);
    await (0, data_1.enhanceData)(basePath, service, fs);
    // Set isServiceTypeEdmx true if service is EDMX
    const isServiceTypeEdmx = service.type === types_1.ServiceType.EDMX;
    // Prepare template folder for manifest and xml updates
    const templateRoot = (0, path_1.join)(__dirname, '../templates');
    await (0, manifest_1.updateManifest)(basePath, service, fs);
    // Dont add backend and mockserver middlewares if service type is CDS
    if (isServiceTypeEdmx) {
        await (0, update_1.addServicesData)(basePath, paths, templateRoot, service, fs);
    }
    else if (!isServiceTypeEdmx && service.annotations) {
        // Update cds files with annotations only if service type is CDS and annotations are provided
        await (0, data_1.updateCdsFilesWithAnnotations)(service.annotations, fs);
    }
    return fs;
}
/**
 * Writes the odata service related file updates to an existing UI5 project specified by the base path.
 *
 * @param {string} basePath - the root path of an existing UI5 application
 * @param {OdataService} service - the OData service instance
 * @param {Editor} [fs] - the memfs editor instance
 * @param {boolean} updateMiddlewares - whether the YAML files for the service (mock-server and fiori-tools-proxy middlewares) should be updated
 * @throws {Error} - if required UI5 project files are not found
 * @returns {Promise<Editor>} the updated memfs editor instance
 */
async function update(basePath, service, fs, updateMiddlewares = true) {
    if (!fs) {
        fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    }
    const paths = await findProjectFiles(basePath, fs);
    const webappPath = await (0, project_access_1.getWebappPath)(basePath, fs);
    ensureExists(webappPath, ['manifest.json'], fs);
    await (0, data_1.enhanceData)(basePath, service, fs, true);
    // Set isServiceTypeEdmx true if service is EDMX
    const isServiceTypeEdmx = service.type === types_1.ServiceType.EDMX;
    await (0, manifest_1.updateManifest)(basePath, service, fs, true);
    // Dont extend/update backend and mockserver middlewares if service type is CDS
    if (isServiceTypeEdmx) {
        await (0, update_1.updateServicesData)(basePath, paths, service, fs, updateMiddlewares);
    }
    return fs;
}
/**
 * Removes service related data from project files for an existing UI5 project specified by the base path.
 * How the method works:
 * 1. Service and annotation files are removed from manifest.
 * If service type is EDMX:
 * 2. ui5.yaml
 *  - backend data of the service is removed from fiori-tools-proxy middleware
 * 3. ui5-local.yaml
 *  - backend data of the service is removed from fiori-tools-proxy middleware
 *  - service is removed from mockserver middleware
 * 4. ui5-mock.yaml
 *  - service is removed from mockserver middleware
 * If service type is CDS:
 * 2. annotations of the service are removed from CDS files.
 *
 * @param {string} basePath - the root path of an existing UI5 application
 * @param {OdataService} service - the OData service instance
 * @param {string} service.name - name of the OData service instance
 * @param {string} service.path - path of the OData service instance
 * @param {string} service.url - url of the OData service instance
 * @param {ServiceType} service.type - type of the OData service instance
 * @param {OdataService['annotations']} service.annotations - services annotations (EDMX or CDS)
 * @param {Editor} [fs] - the memfs editor instance
 * @throws {Error} - if required UI5 project files are not found
 * @returns {Promise<Editor>} the updated memfs editor instance
 */
async function remove(basePath, service, fs) {
    if (!fs) {
        fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    }
    const paths = await findProjectFiles(basePath, fs);
    const isServiceTypeEdmx = service.type === types_1.ServiceType.EDMX;
    // Remove service related data and files from manifest, middlewares for EDMX services
    if (isServiceTypeEdmx) {
        await (0, delete_1.deleteServiceData)(basePath, paths, service, fs);
    }
    else {
        // Remove annotations from CDS files based on annotations info
        await (0, data_1.removeAnnotationsFromCDSFiles)(service.annotations, fs);
    }
    return fs;
}
//# sourceMappingURL=index.js.map