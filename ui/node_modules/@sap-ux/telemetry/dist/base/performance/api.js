"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceMeasurementAPI = void 0;
const entries_1 = require("./entries");
const types_1 = require("./types");
const performanceNow = require("performance-now");
/**
 *
 */
class PerformanceMeasurementAPI extends types_1.PerformanceMeasurement {
    static initTiming;
    static now = performanceNow;
    static entries = [];
    // reported time is relative to the time the current Node process has started (inferred from process.uptime())
    static initialize() {
        PerformanceMeasurementAPI.initTiming = PerformanceMeasurementAPI.now();
    }
    /**
     * Create a new Mark.
     *
     * @param name Name of mark
     * @param type type of mark
     * @param timing Timestamp when mark is created, measured in ms
     */
    static mark(name, type, timing) {
        const entry = new entries_1.Mark(name, type, timing);
        PerformanceMeasurementAPI.entries.push(entry);
    }
    /**
     * Create a start mark of a measurement.
     *
     * @param name Name of start mark
     * @returns Id to track a measurement
     */
    static startMark(name) {
        const timing = PerformanceMeasurementAPI.now();
        const extendedName = name + timing;
        PerformanceMeasurementAPI.mark(extendedName, types_1.EntryType.START_MARK, timing);
        return extendedName;
    }
    /**
     * Set end mark of a measurement.
     *
     * @param name Name of end mark
     */
    static endMark(name) {
        const timing = PerformanceMeasurementAPI.now();
        PerformanceMeasurementAPI.mark(name, types_1.EntryType.END_MARK, timing);
    }
    /**
     * Measure execution time lenght of a given mark name.
     *
     * @param markName Name of mark
     */
    static measure(markName) {
        const startMark = PerformanceMeasurementAPI.getEntriesByNameType(markName, types_1.EntryType.START_MARK).slice(-1)[0];
        const endMark = PerformanceMeasurementAPI.getEntriesByNameType(markName, types_1.EntryType.END_MARK).slice(-1)[0];
        if (!startMark && !endMark) {
            throw new Error(`Failed to execute 'measure': mark '${markName}' doesn't exist.`);
        }
        else if (!startMark || !endMark) {
            const errMarkType = startMark ? types_1.EntryType.END_MARK : types_1.EntryType.START_MARK;
            throw new Error(`Failed to execute 'measure': mark '${markName}'of type '${errMarkType}' doesn't exist.`);
        }
        const startTime = startMark.getStartTime();
        const endTime = endMark.getStartTime();
        const duration = endTime - startTime;
        const measurement = new entries_1.Measurement(`${markName}`, PerformanceMeasurementAPI.now(), duration);
        PerformanceMeasurementAPI.entries.push(measurement);
    }
    /**
     * @returns All entries
     */
    static getEntries() {
        return PerformanceMeasurementAPI.entries;
    }
    /**
     * Get Mark/Measurement by name.
     *
     * @param name Name of entry
     * @returns array of marks/measurements
     */
    static getEntriesByName(name) {
        return PerformanceMeasurementAPI.entries.filter((entry) => entry.name === name);
    }
    /**
     * Get Mark/Measurement by name and type.
     *
     * @param name Name of entry
     * @param type EntryType
     * @returns array of marks/measurements
     */
    static getEntriesByNameType(name, type) {
        return PerformanceMeasurementAPI.entries.filter((entry) => entry.name === name && entry.type === type);
    }
    /**
     * Get Mark/Measurement by type.
     *
     * @param type EntryType
     * @returns array of marks/measurements
     */
    static getEntriesByType(type) {
        return PerformanceMeasurementAPI.entries.filter((entry) => entry.type === type);
    }
    /**
     * Get duration of a measurement.
     *
     * @param name Name of a measurement
     * @returns time length in ms
     */
    static getMeasurementDuration(name) {
        const entry = PerformanceMeasurementAPI.getEntriesByNameType(name, types_1.EntryType.MEASUREMENT).slice(-1)[0];
        return entry.getDurationTime();
    }
    static clearEntries() {
        PerformanceMeasurementAPI.entries = [];
    }
}
exports.PerformanceMeasurementAPI = PerformanceMeasurementAPI;
PerformanceMeasurementAPI.initialize();
//# sourceMappingURL=api.js.map