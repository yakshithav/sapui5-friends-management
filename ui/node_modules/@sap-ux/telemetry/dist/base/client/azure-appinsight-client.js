"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationInsightClient = void 0;
const client_1 = require("./client");
const appInsights = __importStar(require("applicationinsights"));
const event_header_1 = require("../types/event-header");
const sample_rate_1 = require("../types/sample-rate");
const azure_client_config_1 = require("../utils/azure-client-config");
const config_state_1 = require("../config-state");
/**
 *
 */
class ApplicationInsightClient extends client_1.Client {
    clients;
    /**
     *
     * @param applicationKey Application key to identify the Azure Application Insight resource
     * @param extensionName Unique name of the extension in the format of {publisher}.{extension}
     * @param extensionVersion Conventional version number of the extension
     */
    constructor(applicationKey, extensionName, extensionVersion) {
        super();
        this.clients = new Map();
        this.applicationKey = applicationKey;
        this.extensionVersion = extensionVersion;
        this.extensionName = extensionName;
        const clientOnePercent = this.createTelemetryClient(sample_rate_1.SampleRate.OnePercent);
        const clientTenPercent = this.createTelemetryClient(sample_rate_1.SampleRate.TenPercent);
        const clientNoSampling = this.createTelemetryClient(sample_rate_1.SampleRate.NoSampling);
        this.clients.set(sample_rate_1.SampleRate.OnePercent, clientOnePercent);
        this.clients.set(sample_rate_1.SampleRate.TenPercent, clientTenPercent);
        this.clients.set(sample_rate_1.SampleRate.NoSampling, clientNoSampling);
    }
    /**
     * Send a telemetry event to Azure Application Insights. This API makes sure the telemetry event
     * is flushed to Azure backend before executing the next statement. Since this API blocks
     * normal execution flow, please use this API cautiously. See `report()` method for non-blocking
     * usage.
     *
     * @param eventName Categorize the type of the event within the scope of an extension.
     * @param properties A set of string properties to be reported
     * @param measurements  A set of numeric measurements to be reported
     * @param sampleRate Sampling the event to be sent
     * @param ignoreSettings Ignore telemetryEnabled settings and skip submitting telemetry data
     * @returns Promise<void>
     */
    reportBlocking(eventName, properties, measurements, sampleRate, ignoreSettings = false) {
        if (!ignoreSettings || config_state_1.TelemetrySettings.telemetryEnabled) {
            const { client, event } = this.prepareClientAndEvent(eventName, properties, measurements, sampleRate);
            return this.trackEventBlocking(client, event);
        }
        return Promise.resolve();
    }
    /**
     * Send a telemetry event to Azure Application Insights. The telemetry event sending is still non-blocking
     * in this API. To make sure telemetry event is sent to Azure backend before next statement, please see
     * `reportBlocking()`.
     *
     * @param eventName Categorize the type of the event within the scope of an extension.
     * @param properties A set of string properties to be reported
     * @param measurements  A set of numeric measurements to be reported
     * @param sampleRate Sampling the event to be sent
     * @param telemetryHelperProperties Properties that are passed to specific TelemetryClient for generating specific properties (E.g. ToolsSuiteTelemetryClient)
     * @param ignoreSettings Ignore telemetryEnabled settings and skip submitting telemetry data
     */
    async report(eventName, properties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings) {
        if ((ignoreSettings !== undefined && !ignoreSettings) || !config_state_1.TelemetrySettings.telemetryEnabled) {
            return;
        }
        const { client, event } = this.prepareClientAndEvent(eventName, properties, measurements, sampleRate);
        this.trackEvent(client, event);
    }
    /**
     * Provide specification of telemetry event to be sent.
     *
     * @param eventName Categorize the type of the event within the scope of an extension.
     * @param properties A set of string properties to be reported
     * @param measurements A set of numeric measurements to be reported
     * @param sampleRate  Sampling the event to be sent
     * @returns TelemetryClient instance and telemetry event
     */
    prepareClientAndEvent(eventName, properties, measurements, sampleRate = sample_rate_1.SampleRate.NoSampling) {
        const client = this.clients.get(sampleRate);
        const eventHeader = new event_header_1.EventHeader(this.extensionName, eventName);
        const event = {
            name: eventHeader.toString(),
            properties: properties,
            measurements: measurements
        };
        return {
            client,
            event
        };
    }
    /**
     * Send telemetry event in blocking style. It blocks
     * the subsequent statements until telemetry event has been sent.
     *
     * @param client TelemetryClient instance
     * @param event Telemetry event
     * @returns Promise<void>
     */
    async trackEventBlocking(client, event) {
        if (process.env.SAP_UX_FIORI_TOOLS_DISABLE_TELEMETRY === 'true') {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            try {
                client.trackEvent(event);
                client.flush({
                    callback: () => resolve()
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * Send teleemtry event in non-blocking fashion.
     *
     * @param client Telemetry client instance
     * @param event Telemetry event
     * @returns Send telemetry succeeded or not
     */
    trackEvent(client, event) {
        if (process.env.SAP_UX_FIORI_TOOLS_DISABLE_TELEMETRY !== 'true') {
            client.trackEvent(event);
            return true;
        }
        return false;
    }
    /**
     * Create telemetry client instance based on sample rate.
     *
     * @param sampleRate Sampling telemetry event
     * @returns Telemetry client instance
     */
    createTelemetryClient(sampleRate) {
        let sampleRateNumer;
        switch (sampleRate) {
            case sample_rate_1.SampleRate.OnePercent:
                sampleRateNumer = 1;
                break;
            case sample_rate_1.SampleRate.TenPercent:
                sampleRateNumer = 10;
                break;
            case sample_rate_1.SampleRate.NoSampling:
            default:
                sampleRateNumer = 100;
                break;
        }
        const client = new appInsights.TelemetryClient(this.applicationKey);
        client.config.samplingPercentage = sampleRateNumer;
        (0, azure_client_config_1.configAzureTelemetryClient)(client);
        return client;
    }
}
exports.ApplicationInsightClient = ApplicationInsightClient;
//# sourceMappingURL=azure-appinsight-client.js.map