"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processToolsSuiteTelemetry = processToolsSuiteTelemetry;
exports.getCommonProperties = getCommonProperties;
exports.spawnCommand = spawnCommand;
const btp_utils_1 = require("@sap-ux/btp-utils");
const ui5_config_1 = require("@sap-ux/ui5-config");
const axios_1 = __importDefault(require("axios"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
/**
 * Import with Tree shaking behaviour '@sap/ux-project-access/dist/project/utils'
 * performance optimization to remove unreachable code automatically from esbuild.
 * Esbuild will only bundle parts of your packages that you actually use
 *
 * Note: Without Tree shaking import '@sap/ux-project-access'
 * packages consuming telemetry need to add dependencies manually (for ex: sap/cds)
 * Further, size of generated .vsix will be increased by esbuild
 */
const info_1 = require("@sap-ux/project-access/dist/project/info");
const search_1 = require("@sap-ux/project-access/dist/project/search");
const cap_1 = require("@sap-ux/project-access/dist/project/cap");
const types_1 = require("./types");
const child_process_1 = require("child_process");
const os_1 = __importDefault(require("os"));
const config_state_1 = require("./config-state");
const project_access_1 = require("@sap-ux/project-access");
/**
 * Collect commone properties that needs to be added to telemetry event.
 *
 * @param telemetryHelperProperties Pass to report ApplicationInsightClient.report()
 * @returns Common Fiori project properties
 */
async function processToolsSuiteTelemetry(telemetryHelperProperties) {
    const commonProperties = await getCommonProperties();
    let appProperties = {};
    if (telemetryHelperProperties) {
        appProperties = await getAppProperties(telemetryHelperProperties['appPath']);
    }
    return { ...commonProperties, ...appProperties };
}
/**
 * Get common properties that related to Fiori project runtime environment.
 *
 * @returns Common properties
 */
async function getCommonProperties() {
    const commonProperties = {};
    commonProperties[types_1.CommonProperties.DevSpace] = await getSbasDevspace();
    commonProperties[types_1.CommonProperties.AppStudio] = (0, btp_utils_1.isAppStudio)();
    commonProperties[types_1.CommonProperties.AppStudioBackwardCompatible] = commonProperties[types_1.CommonProperties.AppStudio];
    commonProperties[types_1.CommonProperties.InternlVsExternal] = getInternalVsExternal();
    commonProperties[types_1.CommonProperties.InternlVsExternalBackwardCompatible] =
        commonProperties[types_1.CommonProperties.InternlVsExternal];
    commonProperties[types_1.CommonProperties.NodeVersion] = (await getProcessVersions()).node;
    return commonProperties;
}
/**
 * Obtain dev space type from SBAS rest api.
 *
 * @returns SBAS Dev Space Name. Empty string is returned if unable to fetch workspace type or the environment is not SBAS
 */
async function getSbasDevspace() {
    if ((0, btp_utils_1.isAppStudio)()) {
        try {
            if (!process.env.H2O_URL || !process.env.WORKSPACE_ID) {
                return '';
            }
            const h20Url = process.env.H2O_URL;
            const workspaceId = process.env.WORKSPACE_ID.replace('workspaces-', '');
            const url = `${h20Url}/ws-manager/api/v1/workspace/${workspaceId}`;
            const response = await axios_1.default.get(url);
            if (response.data) {
                const workspaceConfig = response.data;
                // devspace stored in this path
                return workspaceConfig?.config?.annotations?.pack;
            }
        }
        catch (error) {
            // handling error
        }
    }
    return '';
}
/**
 * Get common properties from a give Fiori project path.
 *
 * @param appPath Fiori project path.
 * @returns Properties to be append to properties in telemetry event
 */
async function getAppProperties(appPath) {
    if (!appPath) {
        return {};
    }
    const templateType = await getTemplateType(appPath);
    const deployTarget = await getDeployTarget(appPath);
    const applicationType = await (0, info_1.getAppType)(appPath);
    let odataSource = await getODataSource(appPath);
    // Correct logic in getAppType() implementation, if it's reuse lib type, odata source should be unknown
    if (applicationType === 'Fiori Reuse') {
        odataSource = types_1.ODataSource.UNKNOWN;
    }
    const sourceTemplate = await getSourceTemplate(appPath);
    const appProgrammingLanguage = await (0, info_1.getAppProgrammingLanguage)(appPath);
    const output = {};
    output[types_1.CommonProperties.TemplateType] = templateType;
    output[types_1.CommonProperties.DeployTargetType] = deployTarget;
    output[types_1.CommonProperties.ODataSourceType] = odataSource;
    output[types_1.CommonProperties.AppToolsId] = sourceTemplate.toolsId ?? '';
    output[types_1.CommonProperties.AppProgrammingLanguage] = appProgrammingLanguage;
    output[types_1.CommonProperties.TemplateId] = sourceTemplate.id ?? '';
    output[types_1.CommonProperties.TemplateVersion] = sourceTemplate.version ?? '';
    output[types_1.CommonProperties.ApplicationType] = applicationType ?? '';
    return output;
}
/**
 * Read template type from the .appGenInfo.json file or README.md of an Fiori app.
 *
 * @param appPath Root folder path of Fiori app
 * @returns Template type used in the Fiori app
 */
async function getTemplateType(appPath) {
    const readmeFilePath = path_1.default.join(appPath, 'README.md');
    const appGenInfoPath = path_1.default.join(appPath, '.appGenInfo.json');
    // N.B.: Keep this order i.e .appGenInfo.json file is read first, then README.md.
    if (fs_1.default.existsSync(appGenInfoPath)) {
        const appGenInfo = await fs_1.default.promises.readFile(appGenInfoPath, 'utf-8');
        const appGenInfoParsed = JSON.parse(appGenInfo);
        if (appGenInfoParsed?.generationParameters?.template) {
            return appGenInfoParsed.generationParameters.template.trim();
        }
    }
    if (fs_1.default.existsSync(readmeFilePath)) {
        const readmeContent = await fs_1.default.promises.readFile(readmeFilePath, 'utf-8');
        if (readmeContent) {
            let templateType = '';
            const lines = readmeContent.split(/\r?\n/);
            for (const line of lines) {
                // Check if the line matches the pattern |**Template Used**<br>{{TemplateType}}|
                const regex = /\|\*\*Template Used\*\*<br>(.*?)\|/;
                const match = regex.exec(line);
                if (match && match.length >= 2) {
                    // Extract {{TemplateType}} from the matching pattern
                    templateType = match[1].trim();
                    break;
                }
            }
            return templateType;
        }
    }
    return '';
}
/**
 * Find OData Source type of a given app folder path.
 *
 * @param appPath Root folder path of Fiori app
 * @returns Project Type ABAP | CAPJava | CAPNode | UNKNOWN
 */
async function getODataSource(appPath) {
    try {
        // First attempt: Loop up a folder that contain a pacakge.json that has sapux property as project root
        // If appPath has package.json that contains sapux, it is EDMX project type and we derive odata source
        // is ABAP.
        let projectRoot;
        try {
            projectRoot = await (0, search_1.findProjectRoot)(appPath);
        }
        catch {
            // No project root can be found
        }
        // Second attempt: For FF app, package.json does not have sapux property. Try to find the
        // first parent folder that contain pacakge.json as CAP root. If no such folder exists,
        // use appPath as project root.
        if (!projectRoot) {
            try {
                const appParentFolder = path_1.default.dirname(appPath);
                projectRoot = await (0, search_1.findProjectRoot)(appParentFolder, false);
            }
            catch (e) {
                // No project root can be found at parent folder.
            }
        }
        // Third attempt: CAPJava that doesn't have package.json at project root. We assume
        // the project has default structure <projectRoot>/app/<appPath>, and use parent folder
        // path two levels above appPath as projectRoot. This should cover most cases until we have
        // a better solution
        let isCapJavaWithoutPackageJson = false;
        if (!projectRoot) {
            const directParentFolder = path_1.default.dirname(appPath);
            const twoLevelUpParentFolder = path_1.default.dirname(directParentFolder);
            isCapJavaWithoutPackageJson = await (0, cap_1.isCapJavaProject)(twoLevelUpParentFolder);
            projectRoot = isCapJavaWithoutPackageJson ? twoLevelUpParentFolder : appPath;
        }
        if (isCapJavaWithoutPackageJson) {
            return types_1.ODataSource.CAPJava;
        }
        const projectType = await (0, info_1.getProjectType)(projectRoot);
        return getProjectTypeForTelemetry(projectType);
    }
    catch (e) {
        return types_1.ODataSource.UNKNOWN;
    }
}
/**
 * Map ProjectType to values used for telemetry reporting.
 *
 * @param projectType ProjectType
 * @returns Odata source type
 */
function getProjectTypeForTelemetry(projectType) {
    if (projectType === 'EDMXBackend') {
        return types_1.ODataSource.ABAP;
    }
    else if (projectType === 'CAPNodejs') {
        return types_1.ODataSource.CAPNode;
    }
    else if (projectType === 'CAPJava') {
        return types_1.ODataSource.CAPJava;
    }
    else {
        return types_1.ODataSource.UNKNOWN;
    }
}
/**
 * Read ui5-deploy.yaml to decide if it is CF or ABAP deploy target.
 *
 * @param appPath  appPath Root folder path of Fiori app
 * @returns CF | ABAP | NO_DEPLOY_CONFIG | UNKNOWN_DEPLOY_CONFIG
 */
async function getDeployTarget(appPath) {
    let deployTarget = types_1.DeployTarget.NO_DEPLOY_CONFIG;
    const deployConfigPath = path_1.default.join(appPath, 'ui5-deploy.yaml');
    try {
        await fs_1.default.promises.access(deployConfigPath);
        const deployConfigContent = await fs_1.default.promises.readFile(deployConfigPath, 'utf-8');
        const deployConfig = yaml_1.default.parse(deployConfigContent);
        const customTasks = deployConfig?.builder?.customTasks;
        if (customTasks) {
            const isAbapDeployTarget = customTasks.some((task) => task.name === 'deploy-to-abap');
            deployTarget = isAbapDeployTarget ? types_1.DeployTarget.ABAP : types_1.DeployTarget.CF;
        }
        else {
            deployTarget = types_1.DeployTarget.UNKNOWN_DEPLOY_CONFIG;
        }
    }
    catch {
        // cannot determine deploy target, use default DeployTarget.NO_DEPLOY_CONFIG
    }
    return deployTarget;
}
/**
 * Convert init setting property internalFeaturesEnabled to string value.
 *
 * @returns String value 'internal' | 'external' to be backward compatible with existing telemetry data format.
 */
function getInternalVsExternal() {
    return config_state_1.ToolingTelemetrySettings.internalFeature ? 'internal' : 'external';
}
/**
 * Retrieves the source template configuration from either the standard manifest.json or
 * the ui5.yaml based on the project type.
 *
 * @param {string} appPath - The file system path to the application directory.
 * @returns {Promise<SourceTemplate>} A promise that resolves to the source template configuration object.
 */
async function getSourceTemplate(appPath) {
    const webappPath = await (0, project_access_1.getWebappPath)(appPath);
    const paths = {
        manifest: path_1.default.join(webappPath, 'manifest.json'),
        appdescr: path_1.default.join(webappPath, 'manifest.appdescr_variant'),
        ui5Yaml: path_1.default.join(appPath, 'ui5.yaml')
    };
    try {
        if (fs_1.default.existsSync(paths.manifest)) {
            const manifestStr = await fs_1.default.promises.readFile(paths.manifest, 'utf-8');
            const manifest = JSON.parse(manifestStr);
            return populateSourceTemplate(manifest['sap.app']?.sourceTemplate ?? {});
        }
        if (fs_1.default.existsSync(paths.appdescr) && fs_1.default.existsSync(paths.ui5Yaml)) {
            const baseUi5ConfigContent = await fs_1.default.promises.readFile(paths.ui5Yaml, 'utf-8');
            const ui5Config = await ui5_config_1.UI5Config.newInstance(baseUi5ConfigContent);
            const adp = ui5Config.getCustomConfiguration('adp');
            return populateSourceTemplate(adp?.support ?? {});
        }
    }
    catch {
        // Failed to read manifest.json or manifest.appdescr_variant
    }
    return populateSourceTemplate({});
}
/**
 * Populates default values for the source template if not specified.
 *
 * @param {SourceTemplate} sourceTemplate - Source template object potentially lacking defaults.
 * @returns {SourceTemplate} Source template with defaults populated.
 */
function populateSourceTemplate(sourceTemplate) {
    return {
        id: sourceTemplate.id ?? '',
        version: sourceTemplate.version ?? '',
        toolsId: sourceTemplate.toolsId ?? types_1.ToolsId.NO_TOOLS_ID
    };
}
/**
 * Get node.js runtime version.
 *
 * @returns Node.js version
 */
async function getProcessVersions() {
    try {
        const output = await spawnCommand('node', ['-p', 'JSON.stringify(process.versions)']);
        return JSON.parse(output);
    }
    catch {
        return {};
    }
}
/**
 * Spawn a command to find out node.js version used for the runtime.
 *
 * @param command command name
 * @param commandArgs command arguments
 * @returns Node.js version
 */
function spawnCommand(command, commandArgs) {
    const spawnOptions = process.platform.startsWith('win')
        ? { windowsVerbatimArguments: true, shell: true, cwd: os_1.default.homedir() }
        : { cwd: os_1.default.homedir() };
    return new Promise((resolve, reject) => {
        let output = '';
        const spawnProcess = (0, child_process_1.spawn)(command, commandArgs, spawnOptions);
        spawnProcess.stdout.on('data', (data) => {
            const newData = data.toString();
            output += newData;
        });
        spawnProcess.stderr.on('data', (data) => {
            const newData = data.toString();
            output += newData;
        });
        spawnProcess.on('exit', () => {
            resolve(output);
        });
        spawnProcess.on('error', (error) => {
            reject(error);
        });
    });
}
//# sourceMappingURL=data-processor.js.map