"use strict";

sap.ui.define(["sap/m/MessageToast", "sap/ui/rta/command/CommandFactory", "../utils/error"], function (MessageToast, CommandFactory, ___utils_error) {
  "use strict";

  const getError = ___utils_error["getError"];
  /**
   * Class responsible for handling rta calls
   */
  class CommandExecutor {
    /**
     *
     * @param rta Runtime Authoring
     */
    constructor(rta) {
      this.rta = rta;
    }

    /**
     * Generates command based on given values
     *
     * @param runtimeControl Managed object
     * @param commandName Command name
     * @param modifiedValue Modified value/s
     * @param flexSettings Additional flex settings
     * @param designMetadata Design time metadata
     */
    async getCommand(runtimeControl, commandName, modifiedValue, flexSettings, designMetadata) {
      try {
        return await CommandFactory.getCommandFor(runtimeControl, commandName, modifiedValue, designMetadata, flexSettings);
      } catch (e) {
        const error = getError(e);
        const msgToastErrorMsg = `Could not get command for '${commandName}'. ${error.message}`;
        error.message = msgToastErrorMsg;
        MessageToast.show(msgToastErrorMsg);
        throw error;
      }
    }

    /**
     * Creates composite command without nested commands
     *
     * @param runtimeControl Managed object
     */
    async createCompositeCommand(runtimeControl) {
      try {
        return await CommandFactory.getCommandFor(runtimeControl, 'composite');
      } catch (e) {
        const error = getError(e);
        const msgToastErrorMsg = `Could not get composite command'. ${error.message}`;
        error.message = msgToastErrorMsg;
        MessageToast.show(msgToastErrorMsg);
        throw error;
      }
    }

    /**
     * Pushed and executes the provided command
     *
     * @param command Command
     */
    async pushAndExecuteCommand(command) {
      try {
        /**
         * The change will have pending state and will only be saved to the workspace when the user clicks save icon
         */
        await this.rta.getCommandStack().pushAndExecute(command);
      } catch (e) {
        const error = getError(e);
        MessageToast.show(error.message);
        throw error;
      }
    }
  }
  return CommandExecutor;
});
//# sourceMappingURL=command-executor.js.map