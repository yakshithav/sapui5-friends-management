"use strict";

sap.ui.define(["sap/base/Log", "../../utils/core", "../../utils/error", "../utils", "./editable", "../../utils/fe-v4"], function (Log, ____utils_core, ____utils_error, ___utils, ___editable, ____utils_fe_v4) {
  "use strict";

  const getControlById = ____utils_core["getControlById"];
  const getError = ____utils_error["getError"];
  const getOverlay = ___utils["getOverlay"];
  const isEditable = ___editable["isEditable"];
  const getConfigMapControlIdMap = ____utils_fe_v4["getConfigMapControlIdMap"];
  const getPageName = ____utils_fe_v4["getPageName"];
  /**
   * Retrieves additional data for a given control ID.
   *
   * @param id The unique identifier of the control.
   * @returns An object containing the text and the technical name of the control.
   */
  function getAdditionalData(id) {
    const control = getControlById(id);
    if (!control) {
      return {};
    }
    const metadata = control.getMetadata();
    let details = {};
    const technicalName = metadata.getElementName();
    if (technicalName) {
      details.technicalName = technicalName;
    }
    if (metadata.getProperty('text')) {
      const text = control.getProperty('text');
      if (typeof text === 'string' && text.trim() !== '') {
        details.text = text;
      }
    }
    return details;
  }

  /**
   * Gets the children nodes of an aggregation type node.
   *
   * @param current The current node to retrieve children from
   * @returns An array of children nodes, or an empty array if none are found
   */
  function getChildren(current) {
    return (current.elements ?? []).flatMap(element => element.type === 'aggregation' ? element.elements ?? [] : []);
  }

  /**
   * Adds a new child node to the extension point's children array based on the given control ID.
   *
   * @param {string} id - The unique identifier of the control to be added as a child node.
   * @param {OutlineNode[]} children - The array of children nodes to which the new node will be added.
   * @param {ChangeService} changeService - Change service for change stack event handling.
   */
  function addChildToExtensionPoint(id, children, changeService) {
    const {
      text,
      technicalName
    } = getAdditionalData(id);
    const editable = isEditable(changeService, id);
    children.push({
      controlId: id,
      controlType: technicalName ?? 'sap.ui.extensionpoint.child',
      name: text ?? id,
      visible: true,
      editable,
      children: [],
      hasDefaultContent: false
    });
  }
  /**
   * Creates control index for all controls in the app.
   *
   * @param {ControlTreeIndex} controlIndex - Control index for the ui5 app.
   * @param {OutlineNode} node - control node added to the outline.
   */
  function indexNode(controlIndex, node) {
    const indexedControls = controlIndex[node.controlType];
    if (indexedControls) {
      indexedControls.push(node);
    } else {
      controlIndex[node.controlType] = [node];
    }
  }
  function addToPropertyIdMap(node, propertyIdMap) {
    const control = getControlById(node.controlId);
    if (control) {
      const overlay = getOverlay(control);
      const overlayData = overlay?.getDesignTimeMetadata().getData();
      if (!overlayData?.manifestPropertyPath) {
        return;
      }
      if (overlayData) {
        const path = overlayData?.manifestPropertyPath?.(control);
        const pageName = getPageName(control);
        const key = getConfigMapControlIdMap(pageName, path.split('/').filter(item => item));
        if (key) {
          if (!propertyIdMap.get(key)) {
            propertyIdMap.set(key, []);
          }
          propertyIdMap.get(key)?.push(node.controlId);
        }
      }
    }
  }

  /**
   * Transform node.
   *
   * @param input outline view node
   * @param scenario type of project
   * @param controlIndex Control tree index
   * @param changeService ChangeService for change stack event handling.
   * @param propertyIdMap ChangeService for change stack event handling.
   * @returns transformed outline tree nodes
   */
  async function transformNodes(input, scenario, controlIndex, changeService, propertyIdMap) {
    const stack = [...input];
    const items = [];
    while (stack.length) {
      try {
        const current = stack.shift();
        const editable = isEditable(changeService, current?.id);
        const isAdp = scenario === 'ADAPTATION_PROJECT';
        const isExtPoint = current?.type === 'extensionPoint';
        if (current?.type === 'element') {
          const children = getChildren(current);
          const {
            text
          } = getAdditionalData(current.id);
          const technicalName = current.technicalName.split('.').slice(-1)[0];
          const transformedChildren = isAdp ? await handleDuplicateNodes(children, scenario, controlIndex, changeService, propertyIdMap) : await transformNodes(children, scenario, controlIndex, changeService, propertyIdMap);
          const node = {
            controlId: current.id,
            controlType: current.technicalName,
            name: text ?? technicalName,
            editable,
            visible: current.visible ?? true,
            children: transformedChildren
          };
          indexNode(controlIndex, node);
          addToPropertyIdMap(node, propertyIdMap);
          items.push(node);
        }
        if (isAdp && isExtPoint) {
          const {
            defaultContent = [],
            createdControls = []
          } = current.extensionPointInfo;
          let children = [];
          // We can combine both because there can only be either defaultContent or createdControls for one extension point node.
          [...defaultContent, ...createdControls].forEach(id => {
            addChildToExtensionPoint(id, children, changeService);
          });
          const node = {
            controlId: `${current.id}--${current.name ?? ''}`,
            controlType: current.technicalName,
            name: current.name ?? '',
            editable,
            visible: current.visible ?? true,
            children,
            hasDefaultContent: defaultContent.length > 0
          };
          items.push(node);
        }
      } catch (error) {
        Log.error('Failed to transform outline node!', getError(error));
      }
    }
    return items;
  }

  /**
   * Handles duplicate nodes that are retrieved from extension point default content and created controls,
   * if they exist under an extension point these controls are removed from the children array
   *
   * @param children outline view node children
   * @param scenario type of project
   * @param controlIndex Control tree index
   * @param changeService ChangeService for change stack event handling.
   * @param propertyIdMap  Map<string, string[]>.
   * @returns transformed outline tree nodes
   */
  async function handleDuplicateNodes(children, scenario, controlIndex, changeService, propertyIdMap) {
    const extPointIDs = new Set();
    children.forEach(child => {
      if (child.type === 'extensionPoint') {
        const {
          defaultContent = [],
          createdControls = []
        } = child.extensionPointInfo;
        [...defaultContent, ...createdControls].forEach(id => extPointIDs.add(id));
      }
    });
    const uniqueChildren = children.filter(child => !extPointIDs.has(child.id));
    return transformNodes(uniqueChildren, scenario, controlIndex, changeService, propertyIdMap);
  }
  var __exports = {
    __esModule: true
  };
  __exports.transformNodes = transformNodes;
  __exports.handleDuplicateNodes = handleDuplicateNodes;
  return __exports;
});
//# sourceMappingURL=nodes.js.map