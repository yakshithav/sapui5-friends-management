"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemDataProvider = void 0;
const hybrid_1 = require("../data-access/hybrid");
const backend_system_1 = require("../entities/backend-system");
const constants_1 = require("./constants");
const utils_1 = require("../utils");
const SystemDataProvider = class {
    dataAccessor;
    entityName = constants_1.Entities.BackendSystem;
    logger;
    constructor(logger, options = {}) {
        this.logger = logger;
        this.dataAccessor = (0, hybrid_1.getHybridStore)(this.logger, options);
    }
    async read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
    }
    async write(entity) {
        let e;
        if (!(entity instanceof backend_system_1.BackendSystem)) {
            // We need to use the correct class otherwise the annotations are not effective
            e = new backend_system_1.BackendSystem({ ...entity });
        }
        else {
            e = entity;
        }
        return this.dataAccessor.write({
            entityName: this.entityName,
            id: backend_system_1.BackendSystemKey.from(entity).getId(),
            entity: e
        });
    }
    async delete(entity) {
        return this.dataAccessor.del({
            entityName: this.entityName,
            id: backend_system_1.BackendSystemKey.from(entity).getId()
        });
    }
    async getAll({ includeSensitiveData = true } = {}) {
        let systems = await this.dataAccessor.readAll({ entityName: this.entityName, includeSensitiveData });
        if (!includeSensitiveData) {
            const allMigrated = await this.ensureSystemTypesExist(systems);
            if (!allMigrated) {
                // Re-read to ensure we have the updated data
                systems = await this.dataAccessor.readAll({
                    entityName: this.entityName,
                    includeSensitiveData
                });
            }
        }
        for (const id of Object.keys(systems)) {
            const system = systems[id];
            if (!system?.url?.trim()) {
                this.logger.warn(`Filtering system with ID [${id}] as it seems corrupt. Run repair`);
                delete systems[id];
            }
        }
        return Object.values(systems);
    }
    async ensureSystemTypesExist(systems) {
        let allSystemsHaveType = true;
        for (const [id, system] of Object.entries(systems)) {
            if (!system?.systemType) {
                allSystemsHaveType = false;
                await this.assignSystemType(id);
            }
        }
        return allSystemsHaveType;
    }
    /**
     * Temporary migration function to infer and assign a systemType to a system by ID.
     *
     * @param systemId ID of the system to migrate
     */
    async assignSystemType(systemId) {
        const system = await this.dataAccessor.read({ entityName: this.entityName, id: systemId });
        if (system) {
            const inferredType = (0, utils_1.getBackendSystemType)(system);
            if (inferredType) {
                await this.dataAccessor.partialUpdate({
                    entityName: this.entityName,
                    id: systemId,
                    entity: { systemType: inferredType }
                });
            }
        }
    }
};
exports.SystemDataProvider = SystemDataProvider;
//# sourceMappingURL=backend-system.js.map