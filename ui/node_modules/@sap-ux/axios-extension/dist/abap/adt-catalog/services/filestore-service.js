"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStoreService = void 0;
const adt_service_1 = require("./adt-service");
const fast_xml_parser_1 = require("fast-xml-parser");
/**
 * FileStoreService implements ADT requests to obtain the content
 * of deployed archive.
 */
class FileStoreService extends adt_service_1.AdtService {
    /**
     * @see AdtService.getAdtCatagory()
     */
    static adtCategory = {
        scheme: 'http://www.sap.com/adt/categories/filestore',
        term: 'filestore-ui5-bsp'
    };
    /**
     * Get ADT scheme ID.
     *
     * @returns AdtCategory
     */
    static getAdtCatagory() {
        return FileStoreService.adtCategory;
    }
    /**
     * If target `path` is a file, the file content is returned as string type.
     * If target `path` is a folder, files and folders in this folder are returned as an array
     * of ArchiveFileNode objects.
     *
     * @see ArchiveFileNode
     * @param type
     *  Specifies if input `path` refers to a file or a folder. When starting exploring
     *  the file structure from the root, type should be set to `folder`. The type information
     *  of files and folders inside root folder can be found in the returned `ArchiveFileNode` entries.
     * @param appName Deployed Fiori app name
     * @param path
     *   Default value is empty string. In this case the output would be folder structure information of the root folder.
     *   Otherwise provide path to a folder or a file in the deployed archive. E.g. `/webapp/index.html`.
     * @returns Folder content (ArchiveFileNode[]) | file content (string)
     */
    async getAppArchiveContent(type, appName, path = '') {
        const contentType = type === 'folder' ? 'application/atom+xml' : 'application/octet-stream';
        const config = {
            headers: {
                Accept: 'application/xml',
                'Content-Type': contentType
            }
        };
        if (path && !path.startsWith('/')) {
            throw new Error('Input argument "path" needs to start with /');
        }
        const encodedFullPath = encodeURIComponent(`${appName}${path}`);
        const response = await this.get(`/${encodedFullPath}/content`, config);
        return this.parseArchiveContentResponse(appName, response.data, type);
    }
    /**
     * Parse response data from ADT service. If the content is XML document of
     * folder structure, this method returns a list of `ArchiveFileNode` object. If the content
     * is text string, this method returns the text cotent.
     *
     * @see ArchiveFileNode
     * @param appName Deployed Fiori app name
     * @param responseData Response from ADT service
     * @param type Reponse data is the file content or folder content.
     * @returns Folder content (ArchiveFileNode[]) | file content (string)
     */
    parseArchiveContentResponse(appName, responseData, type) {
        // File content that is not xml data.
        if (type === 'file') {
            return responseData;
        }
        // A list of file/folder items in the response data as xml string.
        if (fast_xml_parser_1.XMLValidator.validate(responseData) !== true) {
            throw new Error('Invalid XML content');
        }
        const options = {
            attributeNamePrefix: '',
            ignoreAttributes: false,
            ignoreNameSpace: true,
            parseAttributeValue: true,
            removeNSPrefix: true
        };
        const parser = new fast_xml_parser_1.XMLParser(options);
        const parsed = parser.parse(responseData, true);
        let fileNodeArray = [];
        if (parsed?.feed) {
            if (Array.isArray(parsed.feed.entry)) {
                fileNodeArray = parsed.feed.entry;
            }
            else {
                fileNodeArray = [parsed.feed.entry];
            }
        }
        return fileNodeArray.map((fileNode) => {
            const exposedFileNode = {
                basename: fileNode.title.split('/').pop(),
                path: fileNode.title.substring(appName.length),
                type: fileNode.category.term
            };
            return exposedFileNode;
        });
    }
}
exports.FileStoreService = FileStoreService;
//# sourceMappingURL=filestore-service.js.map