"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uaa = void 0;
const open = require("open");
const axios_1 = __importDefault(require("axios"));
const http_1 = __importDefault(require("http"));
const qs_1 = __importDefault(require("qs"));
const redirect_1 = require("./redirect");
const message_1 = require("../abap/message");
const error_1 = require("./error");
const static_1 = require("./static");
const connection_1 = require("./connection");
/**
 * A class representing interactions with an SAP BTP UAA service
 */
class Uaa {
    log;
    serviceInfo;
    /**
     * @param serviceInfo service Information
     * @param log logger
     */
    constructor(serviceInfo, log) {
        this.log = log;
        this.validatePropertyExists(serviceInfo.uaa.clientid, 'Client ID missing');
        this.validatePropertyExists(serviceInfo.uaa.clientsecret, 'Client Secret missing');
        this.validatePropertyExists(serviceInfo.uaa.url, 'UAA URL missing');
        this.serviceInfo = serviceInfo;
    }
    /**
     * @param property property
     * @param errMsg error message
     */
    validatePropertyExists(property, errMsg) {
        if (!property) {
            throw Error(errMsg);
        }
    }
    /**
     * Getter for uaa url.
     *
     * @returns uaa url
     */
    get url() {
        return this.serviceInfo.uaa.url.replace(/\/?$/, '');
    }
    /**
     * Getter for client id.
     *
     * @returns client id
     */
    get clientid() {
        return this.serviceInfo.uaa.clientid;
    }
    /**
     * Getter for client secret.
     *
     * @returns client secret
     */
    get clientsecret() {
        return this.serviceInfo.uaa.clientsecret;
    }
    /**
     * Getter for logout url.
     *
     * @returns logout url
     */
    get logoutUrl() {
        return this.url + '/logout.do';
    }
    /**
     * Getter for system id.
     *
     * @returns system id
     */
    get systemId() {
        return this.serviceInfo.systemid;
    }
    /**
     * Getter for username.
     *
     * @returns system id
     */
    get username() {
        return this.serviceInfo.uaa.username;
    }
    /**
     * Getter for password.
     *
     * @returns system id
     */
    get password() {
        return this.serviceInfo.uaa.password;
    }
    /**
     * Generates a request url based on the provided redirect url.
     *
     * @param params config parameters
     * @param params.redirectUri redirect url
     * @returns authentication code request url
     */
    getAuthCodeUrl({ redirectUri }) {
        return (this.url +
            '/oauth/authorize?' +
            qs_1.default.stringify({
                'response_type': 'code',
                'redirect_uri': redirectUri,
                'client_id': this.clientid
            }));
    }
    /**
     * Generate an access token using grant_type password to the authorization service (XSUAA).
     *
     * @returns an axios request config
     */
    getTokenRequestForClientCredential() {
        const secret = `${this.clientid}:${this.clientsecret}`;
        return {
            url: `${this.url}/oauth/token`,
            method: 'POST',
            data: qs_1.default.stringify({
                'grant_type': 'password',
                'username': this.username,
                'password': this.password
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json',
                Authorization: `Basic ${Buffer.from(secret).toString('base64')}`
            }
        };
    }
    /**
     * Generate an Axios token request configuration for fetching a token.
     *
     * @param params config parameters
     * @param params.redirectUri redirect url
     * @param params.authCode authentication code
     * @returns an axios request config
     */
    getTokenRequestForAuthCode({ redirectUri, authCode }) {
        return {
            url: `${this.url}/oauth/token`,
            auth: { username: this.clientid, password: this.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                code: authCode,
                'grant_type': 'authorization_code',
                'redirect_uri': redirectUri,
                'response_type': 'token'
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    /**
     * Generate an Axios token request configuration for fetching a token.
     *
     * @param refreshToken existing refresh token
     * @returns an axios request config
     */
    getTokenRequestForRefreshToken(refreshToken) {
        return {
            url: `${this.url}/oauth/token`,
            auth: { username: this.clientid, password: this.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                'grant_type': 'refresh_token',
                'refresh_token': refreshToken
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    /**
     * Get user information.
     *
     * @param accessToken valid access token
     * @returns user name or undefined
     */
    async getUserInfo(accessToken) {
        const userInfoResp = await axios_1.default.request({
            url: `${this.url}/userinfo`,
            method: 'GET',
            headers: {
                authorization: `bearer ${accessToken}`
            }
        });
        return userInfoResp?.data?.email || userInfoResp?.data?.name;
    }
    /**
     * Get an authentication code.
     *
     * @param timeout timeout
     * @returns an object containing an authentication code and a redirect object
     */
    async getAuthCode(timeout = connection_1.defaultTimeout) {
        return new Promise((resolve, reject) => {
            // eslint-disable-next-line prefer-const
            let redirect;
            // eslint-disable-next-line prefer-const
            let server;
            const handleTimeout = () => {
                server?.close();
                reject(new error_1.UAATimeoutError(`Timeout. Did not get a response within ${(0, message_1.prettyPrintTimeInMs)(timeout)}`));
            };
            const timer = setTimeout(handleTimeout, timeout);
            server = http_1.default.createServer((req, res) => {
                const reqUrl = new URL(req.url, `http://${req.headers.host}`);
                if (reqUrl.pathname === redirect_1.Redirect.path) {
                    res.writeHead(200, { 'Content-Type': 'text/html' });
                    res.end(Buffer.from((0, static_1.redirectSuccessHtml)(this.logoutUrl, this.systemId)));
                    this.log.info('Got authCode');
                    resolve({ authCode: reqUrl.searchParams.get('code') + '', redirect });
                    if (timer) {
                        clearTimeout(timer);
                    }
                    server.close();
                }
            });
            // Start listening. Let the OS assign an available port
            server.listen();
            redirect = new redirect_1.Redirect(server.address().port);
            const oauthUrl = this.getAuthCodeUrl({ redirectUri: redirect.url() });
            open(oauthUrl)?.catch((error) => this.log.error(error));
        });
    }
    /**
     * @param refreshToken refreshToken
     * @param refreshTokenChangedCb refreshTokenChanged callback function
     * @returns an access token.
     */
    async getAccessToken(refreshToken, refreshTokenChangedCb) {
        let response;
        let startFreshLogin = false;
        let newRefreshToken;
        if (refreshToken) {
            this.log.info('Refresh token passed in');
            const tokenRequest = this.getTokenRequestForRefreshToken(refreshToken);
            try {
                response = await axios_1.default.request(tokenRequest);
                // Has refresh token expired?
                if (response.status === 401 || response.data.error === 'invalid_token') {
                    startFreshLogin = true;
                    this.log.warn('Cannot use stored refresh token. Starting fresh request');
                }
                else if (refreshToken !== response.data.refresh_token) {
                    this.log.info('New refresh token issued');
                    newRefreshToken = response.data.refresh_token;
                }
            }
            catch (e) {
                startFreshLogin = true;
            }
        }
        if (!refreshToken || startFreshLogin) {
            const { authCode, redirect } = await this.getAuthCode();
            const tokenRequest = this.getTokenRequestForAuthCode({
                redirectUri: redirect.url(), // Redirection URL needs to match
                authCode
            });
            response = await axios_1.default.request(tokenRequest);
            this.log.info('Refresh token issued');
            newRefreshToken = response.data.refresh_token;
        }
        if (refreshTokenChangedCb) {
            this.log.info('Sending notification that refresh token changed');
            await refreshTokenChangedCb(newRefreshToken, response?.data?.access_token);
        }
        this.log.info('Got access token successfully');
        return response?.data?.access_token;
    }
    /**
     * Retrieve an access token using the client credentials.
     *
     * @returns an access token using the BTP UAA credentials
     */
    async getAccessTokenWithClientCredentials() {
        const tokenRequest = this.getTokenRequestForClientCredential();
        const response = await axios_1.default.request(tokenRequest);
        this.log.info('Got access token successfully using client credentials');
        return response?.data?.access_token;
    }
}
exports.Uaa = Uaa;
//# sourceMappingURL=uaa.js.map