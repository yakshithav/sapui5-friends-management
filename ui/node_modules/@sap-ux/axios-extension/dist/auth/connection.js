"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cookies = exports.defaultTimeout = exports.CSRF = void 0;
exports.attachConnectionHandler = attachConnectionHandler;
const axios_1 = require("axios");
const detect_content_type_1 = __importDefault(require("detect-content-type"));
var CSRF;
(function (CSRF) {
    CSRF["RequestHeaderName"] = "X-Csrf-Token";
    CSRF["RequestHeaderValue"] = "Fetch";
    CSRF["ResponseHeaderName"] = "x-csrf-token";
})(CSRF || (exports.CSRF = CSRF = {}));
/** Default connection timeout (milliseconds) */
exports.defaultTimeout = 60 * 1000; // 1 minute
/**
 * Helper class for managing cookies.
 */
class Cookies {
    cookies = {};
    /**
     * Update the cookies based on 'set-cookie' headers of a response.
     *
     * @param response http response containing a headers object
     * @returns cookies object
     */
    setCookies(response) {
        if (response.headers?.['set-cookie']) {
            response.headers['set-cookie'].forEach((cookieString) => this.addCookie(cookieString));
        }
        return this;
    }
    /**
     * Update cookies based on a string representing a cookie.
     *
     * @param cookieString string representing a cookie
     * @returns cookies object
     */
    addCookie(cookieString) {
        const cookie = cookieString.split(';');
        const [key, ...values] = cookie[0]?.split('=') || [];
        const value = values?.join('='); // Account for embedded '=' in the value
        if (key && cookieString.indexOf('Max-Age=0') >= 0) {
            delete this.cookies[key];
        }
        else if (key && value) {
            this.cookies[key] = value;
        }
        return this;
    }
    /**
     * Serialize all cookies as string formatted for the 'Cookie' header.
     *
     * @returns serialized cookies
     */
    toString() {
        const cookies = [];
        Object.keys(this.cookies).forEach((key) => {
            cookies.push(`${key}=${this.cookies[key]}`);
        });
        return cookies.join('; ');
    }
}
exports.Cookies = Cookies;
/**
 * Check the response if SAML is required.
 *
 * @param response response from the backend
 * @returns true if SAML is required
 */
function isSamlLogonNeeded(response) {
    return (response?.status === 200 &&
        isHtmlResponse(response) &&
        typeof response.data === 'string' &&
        !!response.data.match(/saml/i));
}
/**
 * SAP systems can choose to respond with a 200 and an HTML login page that the module cannot handle, therefore, convert it into a 401.
 *
 * @param response response from the backend
 * @throws an error with status 401 if an HTML form is returned
 */
function throwIfHtmlLoginForm(response) {
    if (response?.status !== 200) {
        return;
    }
    if (response.headers['sap-err-id'] === 'ICFLOGONREQUIRED' || isHtmlLoginForm(response)) {
        const err = new Error();
        err.response = { status: 401 };
        err.isAxiosError = true;
        err.toJSON = () => {
            return { status: 401 };
        };
        throw err;
    }
}
/**
 * @param response AxiosResponse
 * @returns true if the contents are determined to be HTML
 */
function isHtmlResponse(response) {
    return getContentType(response.headers['content-type'], response.data).startsWith('text/html');
}
/**
 * @param response AxiosResponse
 * @returns true if we get an HTML login form
 */
function isHtmlLoginForm(response) {
    return isHtmlResponse(response) && typeof response.data === 'string' && !!response.data.match(/log[io]n/i);
}
/**
 * @param contentTypeHeader contents of Content-Type header (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)
 * @param responseData data received in HTTP response. This is used to infer the Content-Type, if the header is missing or ambiguous
 * @returns content type
 */
function getContentType(contentTypeHeader, responseData) {
    if (contentTypeHeader) {
        return contentTypeHeader.toLowerCase();
    }
    else if (typeof responseData === 'string') {
        // Try to infer it from the data
        return (0, detect_content_type_1.default)(Buffer.from(responseData))?.toLowerCase() ?? '';
    }
    else {
        return '';
    }
}
/**
 * Attach a connection handler to the given service provider.
 *
 * @param provider any service provider
 */
function attachConnectionHandler(provider) {
    // fetch xsrf token with the first request
    const oneTimeReqInterceptorId = provider.interceptors.request.use((request) => {
        request.headers = request.headers ?? new axios_1.AxiosHeaders();
        request.headers[CSRF.RequestHeaderName] = CSRF.RequestHeaderValue;
        return request;
    });
    // throw error if the user is unauthorized otherwise, remove interceptor if successfully connected
    const oneTimeRespInterceptorId = provider.interceptors.response.use((response) => {
        // if a redirect to a SAML login page happened try again with disable saml param
        if (isSamlLogonNeeded(response) && provider.defaults.params?.saml2 !== 'disabled') {
            provider.defaults.params = provider.defaults.params ?? {};
            provider.defaults.params.saml2 = 'disabled';
            return provider.request(response.config);
        }
        else {
            throwIfHtmlLoginForm(response);
            // remember xsrf token
            if (response.headers?.[CSRF.ResponseHeaderName]) {
                provider.defaults.headers.common[CSRF.RequestHeaderName] =
                    response.headers[CSRF.ResponseHeaderName];
                provider.interceptors.request.eject(oneTimeReqInterceptorId);
            }
            provider.interceptors.response.eject(oneTimeRespInterceptorId);
            return response;
        }
    }, (error) => {
        // remember xsrf token if provided even on error
        if (error.response) {
            if (error.response.headers?.[CSRF.ResponseHeaderName]) {
                provider.defaults.headers.common[CSRF.RequestHeaderName] =
                    error.response.headers[CSRF.ResponseHeaderName];
                provider.interceptors.request.eject(oneTimeReqInterceptorId);
            }
            provider.cookies.setCookies(error.response);
        }
        throw error;
    });
    // always add cookies to outgoing requests
    provider.interceptors.request.use((request) => {
        request.headers = request.headers ?? new axios_1.AxiosHeaders();
        request.headers.cookie = provider.cookies.toString();
        return request;
    });
    // remember new cookies from each new response
    provider.interceptors.response.use((response) => {
        provider.cookies.setCookies(response);
        return response;
    });
}
//# sourceMappingURL=connection.js.map