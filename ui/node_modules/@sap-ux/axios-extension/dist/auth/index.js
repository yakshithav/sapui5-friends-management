"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uaa = void 0;
exports.attachBasicAuthInterceptor = attachBasicAuthInterceptor;
exports.attachUaaAuthInterceptor = attachUaaAuthInterceptor;
exports.attachReentranceTicketAuthInterceptor = attachReentranceTicketAuthInterceptor;
exports.getReentranceTicketAuthInterceptor = getReentranceTicketAuthInterceptor;
const axios_1 = require("axios");
const reentrance_ticket_1 = require("./reentrance-ticket");
const uaa_1 = require("./uaa");
Object.defineProperty(exports, "Uaa", { enumerable: true, get: function () { return uaa_1.Uaa; } });
__exportStar(require("./connection"), exports);
__exportStar(require("./error"), exports);
/**
 * @param provider Basic Auth Provider
 */
function attachBasicAuthInterceptor(provider) {
    const oneTimeInterceptorId = provider.interceptors.response.use((response) => {
        delete provider.defaults.auth;
        provider.interceptors.response.eject(oneTimeInterceptorId);
        return response;
    });
}
/**
 * @param provider  Abap Service Provider
 * @param service Service Information
 * @param refreshToken refreshToken
 * @param refreshTokenUpdateCb refreshTokenUpdate callback function
 */
function attachUaaAuthInterceptor(provider, service, refreshToken, refreshTokenUpdateCb) {
    const uaa = new uaa_1.Uaa(service, provider.log);
    let token;
    const getToken = async () => {
        return service.uaa?.username
            ? await uaa.getAccessTokenWithClientCredentials()
            : await uaa.getAccessToken(refreshToken, refreshTokenUpdateCb);
    };
    // provide function to fetch user info from UAA if needed
    provider.user = async () => {
        token = token ?? (await getToken());
        return uaa.getUserInfo(token);
    };
    provider.interceptors.request.use(async (request) => {
        token = token ?? (await getToken());
        // add token as auth header
        request.headers = request.headers ?? new axios_1.AxiosHeaders();
        request.headers.authorization = `bearer ${token}`;
        return request;
    });
}
/**
 * Get the reentrace ticket from the backend and add it to the header.
 *
 * @param options options
 * @param options.provider an instance of an ABAP service provider
 */
function attachReentranceTicketAuthInterceptor({ provider }) {
    /* This cannot be a const like eslint claims */
    /* eslint-disable prefer-const */
    let oneTimeInterceptorId;
    const ejectCallback = () => provider.interceptors.request.eject(oneTimeInterceptorId);
    oneTimeInterceptorId = provider.interceptors.request.use(getReentranceTicketAuthInterceptor({ provider, ejectCallback }));
}
/**
 * Get the interceptor that fetches and uses reentrance tickets from the backend.
 *
 * @param options options
 * @param options.provider an instance of an ABAP service provider
 * @param options.ejectCallback  eject Callback Function
 * @returns the interceptor function to fetch and use reentrace tickets
 */
function getReentranceTicketAuthInterceptor({ provider, ejectCallback }) {
    return async (request) => {
        const { reentranceTicket, apiUrl } = await (0, reentrance_ticket_1.getReentranceTicket)({
            backendUrl: provider.defaults.baseURL,
            logger: provider.log
        });
        if (apiUrl && apiUrl != provider.defaults.baseURL) {
            // Reentrance tickets work with API hostnames. If the original URL was not one, this will replace it
            // with the API hostname returned
            provider.log.warn(`Replacing provider's default base URL (${provider.defaults.baseURL}) with API URL: ${apiUrl}`);
            provider.defaults.baseURL = apiUrl;
        }
        request.headers = request.headers ?? new axios_1.AxiosHeaders();
        request.headers.MYSAPSSO2 = reentranceTicket;
        // remove this interceptor since it is not needed anymore
        ejectCallback();
        return request;
    };
}
//# sourceMappingURL=index.js.map