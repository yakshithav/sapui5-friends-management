"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ODataService = exports.ODataVersion = void 0;
const axios_1 = require("axios");
/**
 * OData versions supported by Fiori elements
 */
var ODataVersion;
(function (ODataVersion) {
    ODataVersion["v2"] = "2";
    ODataVersion["v4"] = "4";
})(ODataVersion || (exports.ODataVersion = ODataVersion = {}));
/**
 * Parse a JSON based OData response and extract the content from the OData structure.
 *
 * @param includeV4ControlData unless specified only the value of the parsed v4 odata response is returned, otherwise all additional data is included e.g. `@odata.nextLink`
 * @returns an object of the provided type
 */
function parseODataResponse(includeV4ControlData = false) {
    const data = this.data ? JSON.parse(this.data) : {};
    if (data.d) {
        // v2
        if (data.d.results) {
            return data.d.results;
        }
        else {
            return data.d;
        }
    }
    else if (!includeV4ControlData && data['@odata.context']) {
        // v4
        if (data.value) {
            return data.value;
        }
        else {
            return data;
        }
    }
    // not an OData response, let the caller figure it out
    return data;
}
/**
 * Class extending Axios representing an OData service.
 */
class ODataService extends axios_1.Axios {
    log;
    doc;
    metadataDoc;
    /**
     * Get the service description document.
     *
     * @returns a service description containing all exposed entities
     */
    async document() {
        if (!this.doc) {
            const response = await this.get('/');
            const data = response.odata();
            if (data['EntitySets']) {
                this.doc = data;
            }
            else {
                this.doc = {
                    EntitySets: data.map((obj) => obj.name)
                };
            }
        }
        return this.doc;
    }
    /**
     * Get the metadata of the service.
     *
     * @returns service metadata
     */
    async metadata() {
        if (!this.metadataDoc) {
            const response = await this.get('/$metadata', { headers: { Accept: 'application/xml' } });
            this.metadataDoc = response.data;
        }
        return this.metadataDoc;
    }
    /**
     * Send a get request to the OData service with some preset always used parameters.
     *
     * @param url relative url to the service
     * @param config additional axios request config
     * @param includeV4ControlData include the control information that is not part of the odata value but may be required e.g. `@odata.nextLink`
     * @returns a response enhanced with an OData parse method
     */
    async get(url, config = {}, includeV4ControlData = false) {
        // AxiosRequestConfig `params` property supports plain object or URLSearchParams
        if (config.params instanceof URLSearchParams && !config.params.has('$format') && !config.headers?.Accept) {
            config.params.set('$format', 'json');
            config.headers = config.headers ?? {};
            config.headers.Accept = 'application/json';
        }
        else if (config.params?.['$format'] === undefined && !config.headers?.Accept) {
            config.params = config.params ?? {};
            config.params['$format'] = 'json';
            config.headers = config.headers ?? {};
            config.headers.Accept = 'application/json';
        }
        const response = await super.get(url, config);
        const contentType = response.headers['content-type'] ?? response.headers['Content-Type'];
        if (response.data && (contentType?.includes('application/json') || config.params?.['$format'] === 'json')) {
            response.odata = parseODataResponse.bind(response, includeV4ControlData);
        }
        return response;
    }
}
exports.ODataService = ODataService;
//# sourceMappingURL=odata-service.js.map