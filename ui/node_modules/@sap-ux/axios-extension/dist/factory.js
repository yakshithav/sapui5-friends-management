"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbapCloudEnvironment = exports.PatchedHttpsProxyAgent = void 0;
exports.create = create;
exports.createForAbap = createForAbap;
exports.createForAbapOnCloud = createForAbapOnCloud;
exports.createForDestination = createForDestination;
exports.createServiceForUrl = createServiceForUrl;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const btp_utils_1 = require("@sap-ux/btp-utils");
const https_1 = require("https");
const auth_1 = require("./auth");
const service_provider_1 = require("./base/service-provider");
const abap_1 = require("./abap");
const util_1 = require("util");
const patchTls_1 = require("./base/patchTls");
const proxy_from_env_1 = require("proxy-from-env");
const https_proxy_agent_1 = require("https-proxy-agent");
const http_proxy_agent_1 = require("http-proxy-agent");
/**
 * PatchedHttpsProxyAgent is a custom implementation of HttpsProxyAgent that allows to pass additional options, currently not supported by the original implementation when calling tls.connect
 */
// eslint-disable-next-line jsdoc/require-jsdoc
class PatchedHttpsProxyAgent extends https_proxy_agent_1.HttpsProxyAgent {
    extraOptions;
    /**
     * Extension of the base constructor.
     *
     * @param proxy
     * @param opts
     */
    constructor(proxy, opts) {
        super(proxy, opts);
        this.extraOptions = opts;
    }
    /**
     * Performs transparent encryption of written data and all required TLS negotiation.
     *
     * @param req
     * @param opts
     * @returns {Promise<net.Socket>}
     */
    async connect(req, opts) {
        return super.connect(req, { ...this.extraOptions, ...opts });
    }
}
exports.PatchedHttpsProxyAgent = PatchedHttpsProxyAgent;
/**
 * Create a new instance of given type and set default configuration merged with the given config.
 *
 * @param ProviderType class that will be instantiated
 * @param config axios config with additional extension specific properties
 * @returns instance of the provided class
 */
function createInstance(ProviderType, config) {
    const providerConfig = (0, cloneDeep_1.default)(config);
    const agentOptions = {
        rejectUnauthorized: !providerConfig.ignoreCertErrors
    };
    const localProxy = (0, proxy_from_env_1.getProxyForUrl)(config.baseURL);
    if (localProxy && !(0, btp_utils_1.isAppStudio)()) {
        // axios doesn't handle proxies correctly, instead use a custom agent with axios proxy disabled
        providerConfig.httpsAgent = new PatchedHttpsProxyAgent(localProxy, agentOptions);
        providerConfig.httpAgent = new http_proxy_agent_1.HttpProxyAgent(localProxy);
        providerConfig.proxy = false;
    }
    // Default httpsAgent with optional parameters passed to the agent
    if (!providerConfig.httpsAgent) {
        providerConfig.httpsAgent = new https_1.Agent(agentOptions);
    }
    delete providerConfig.ignoreCertErrors;
    providerConfig.withCredentials = providerConfig?.auth && Object.keys(providerConfig.auth).length > 0;
    /**
     * Make axios throw an error for 4xx errors.
     *
     * @param status - http response status
     * @returns success (true) or error (false)
     */
    providerConfig.validateStatus = (status) => status < 400;
    const instance = new ProviderType(providerConfig);
    instance.defaults.headers = instance.defaults.headers ?? {
        common: {},
        'delete': {},
        put: {},
        get: {},
        post: {},
        head: {},
        patch: {}
    };
    (0, auth_1.attachConnectionHandler)(instance);
    if (providerConfig.auth?.password) {
        (0, auth_1.attachBasicAuthInterceptor)(instance);
    }
    if (config.cookies) {
        config.cookies.split(';').forEach((singleCookieStr) => {
            instance.cookies.addCookie(singleCookieStr.trim());
        });
    }
    if (patchTls_1.TlsPatch.isPatchRequired(config.baseURL)) {
        patchTls_1.TlsPatch.apply();
    }
    return instance;
}
/**
 * Create an instance of a basic service provider.
 *
 * @param config axios config with additional extension specific properties
 * @returns instance of the basic service provider
 */
function create(config) {
    if (typeof config === 'string') {
        return createInstance(service_provider_1.ServiceProvider, {
            baseURL: config
        });
    }
    else {
        return createInstance(service_provider_1.ServiceProvider, config);
    }
}
/**
 * Create an instance of an ABAP service provider.
 *
 * @param config axios config with additional extension specific properties
 * @returns instance of an ABAP service provider
 */
function createForAbap(config) {
    return createInstance(abap_1.AbapServiceProvider, config);
}
/** Supported ABAP environments on the cloud */
var AbapCloudEnvironment;
(function (AbapCloudEnvironment) {
    AbapCloudEnvironment["Standalone"] = "Standalone";
    AbapCloudEnvironment["EmbeddedSteampunk"] = "EmbeddedSteampunk";
})(AbapCloudEnvironment || (exports.AbapCloudEnvironment = AbapCloudEnvironment = {}));
/**
 * Create an instance of an ABAP service provider for a Cloud ABAP system.
 *
 * @param options {@link AbapCloudOptions}
 * @returns instance of an {@link AbapServiceProvider}
 */
function createForAbapOnCloud(options) {
    let provider;
    switch (options.environment) {
        case AbapCloudEnvironment.Standalone: {
            const { service, refreshToken, refreshTokenChangedCb, cookies, ...config } = options;
            provider = createInstance(abap_1.AbapServiceProvider, {
                baseURL: service.url,
                cookies,
                ...config
            });
            if (!cookies) {
                (0, auth_1.attachUaaAuthInterceptor)(provider, service, refreshToken, refreshTokenChangedCb);
            }
            break;
        }
        case AbapCloudEnvironment.EmbeddedSteampunk: {
            const { url, cookies, ...config } = options;
            provider = createInstance(abap_1.AbapServiceProvider, {
                baseURL: url,
                cookies,
                ...config
            });
            if (!cookies) {
                (0, auth_1.attachReentranceTicketAuthInterceptor)({ provider });
            }
            break;
        }
        default:
            const opts = options;
            throw new Error(`Unknown environment type supplied: ${(0, util_1.inspect)(opts)}`);
    }
    return provider;
}
/**
 * Create an instance of a service provider for the given destination.
 *
 * @param options axios config with additional extension specific properties
 * @param destination destination config
 * @param destinationServiceInstance optional id of a destination service instance providing the destination
 * @returns instance of a service provider
 */
function createForDestination(options, destination, destinationServiceInstance) {
    const { cookies, ...config } = options;
    const providerConfig = {
        ...config,
        baseURL: (0, btp_utils_1.getDestinationUrlForAppStudio)(destination.Name, destination.Host ? new URL(destination.Host).pathname : undefined),
        cookies: cookies
    };
    // SAML in AppStudio is not yet supported
    providerConfig.params = providerConfig.params ?? {};
    providerConfig.params.saml2 = 'disabled';
    let provider;
    if ((0, btp_utils_1.isAbapSystem)(destination)) {
        provider = createInstance(abap_1.AbapServiceProvider, providerConfig);
        // For an ABAP destination flow, need to show the destination host URL property instead of the BAS host URL i.e. https://mydest.dest
        provider.publicUrl = destination.Host;
    }
    else {
        provider = createInstance(service_provider_1.ServiceProvider, providerConfig);
    }
    // resolve destination service user on first request if required
    if (destinationServiceInstance) {
        const oneTimeReqInterceptorId = provider.interceptors.request.use(async (request) => {
            const credentials = await (0, btp_utils_1.getCredentialsForDestinationService)(destinationServiceInstance);
            provider.defaults.headers.common[btp_utils_1.BAS_DEST_INSTANCE_CRED_HEADER] = credentials;
            provider.interceptors.request.eject(oneTimeReqInterceptorId);
            return request;
        });
    }
    return provider;
}
/**
 * Create an instance of a basic service provider and then generate an extension for a service based on the given url.
 *
 * @param url full url pointing to a service
 * @param config axios config with additional extension specific properties
 * @returns instance of a service
 */
function createServiceForUrl(url, config = {}) {
    const urlObject = new URL(url);
    config.baseURL = urlObject.origin;
    const searchParams = new URLSearchParams(config.params);
    for (const [key, val] of urlObject.searchParams.entries()) {
        searchParams.append(key, val);
    }
    config.params = searchParams;
    const provider = createInstance(service_provider_1.ServiceProvider, config);
    return provider.service(urlObject.pathname);
}
//# sourceMappingURL=factory.js.map