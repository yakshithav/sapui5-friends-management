import { assign } from "lodash";
import urljoin from "url-join";
import { getEnvValue } from "../utils/core-utils";
import { ENV_H2O_URL } from "../utils/destinations";
import * as devUtils from "../utils/devspace-utils";
import { URL } from "url";

export const BAS_PLAN = "TENANT_PLAN";
export const BUILD_CODE_PLAN = "BUILD_CODE_PLAN";
const BUILD_CODE_FREE = "build-code-free";
const FREE = "free";
const STANDARD = "standard";
const TRIAL = "trial";
const BUILD_CODE = "build-code";
const BUILD_CODE_STANDARD = "buildCodeStandard";
const BUILD_CODE_FREE_VAL = "buildCodeFree";
const BUILD_STANDARD = "buildStandard";
const BUILD_DEFAULT = "build-default";

/**
 * Return information about the current workspace.
 *
 * @returns - devspace information
 */
export function getDevspaceInfo(options?: {
  landscapeUrl: string;
  jwt: string;
  wsId: string;
}): Promise<devUtils.DevspaceInfo> {
  if (!options) {
    // assuming runs in BAS
    options = assign(
      {},
      { landscapeUrl: getEnvValue(ENV_H2O_URL) },
      { wsId: getEnvValue("WORKSPACE_ID").replace("workspaces-", "") },
      { jwt: "" },
    );
  }
  return devUtils
    .getDevSpace(options)
    .then((response) => {
      return devUtils.flattenDevspaceInfo(response.data);
    })
    .catch((e) => {
      const errorDetail =
        e instanceof Error ? `Error message: ${e.message}.` : "";
      throw new Error(
        `Couldn't retrieve devspace information from the (${urljoin(
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- ignore eslint warn
          options!.landscapeUrl,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- ignore eslint warn
          `/ws-manager/api/v1/workspace/${options!.wsId}`,
        )}) URL. ${errorDetail}`,
      );
    });
}

export function getDevSpaces(
  landscapeUrl: string,
  jwt: string,
): Promise<devUtils.DevspaceInfo[]> {
  return devUtils
    .getDevSpaces({ jwt, landscape: landscapeUrl })
    .then((response) => {
      return response.data.map((ds: devUtils.DevspaceApiResults) =>
        devUtils.flattenDevspaceInfo(ds),
      );
    });
}

export function deleteDevSpace(
  landscapeUrl: string,
  jwt: string,
  wsId: string,
): Promise<void> {
  return (
    devUtils
      .deleteDevSpace({ landscape: landscapeUrl, wsId, jwt })
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- suppress eslint warning
      .then((_) => undefined)
  );
}

export function getDevSpacesSpec(
  landscapeUrl: string,
  jwt: string,
): Promise<devUtils.DevSpaceSpec | undefined> {
  return devUtils.getDevSpacesSpec({ landscape: landscapeUrl, jwt });
}

export function getExtensionPacks(
  landscapeUrl: string,
  jwt: string,
): Promise<devUtils.ExtensionPackInfo[]> {
  return devUtils
    .getExtensionPacks({ jwt, landscape: landscapeUrl })
    .then((response) => {
      return response.data.packs.map((ep: devUtils.ExtensionPackInfo) => {
        return {
          name: ep.name,
          description: ep.description,
        };
      });
    });
}

export function createDevSpace(
  landscapeUrl: string,
  jwt: string,
  data: devUtils.DevSpaceCreation,
): Promise<void> {
  return (
    devUtils
      .createDevSpace({ landscape: landscapeUrl, data, jwt })
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- suppress eslint warn
      .then((_) => undefined)
  );
}

export function updateDevSpace(
  landscapeUrl: string,
  jwt: string,
  wsId: string,
  data: devUtils.DevspaceUpdate,
): Promise<void> {
  return (
    devUtils
      .updateDevSpace({ landscape: landscapeUrl, wsId, data, jwt })
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- suppress eslint warn
      .then((_) => undefined)
  );
}

export function isBuildCode(opts?: {
  buildCodePlan?: string;
  wsPlan?: string;
}): boolean {
  let buildCodePlan = opts?.buildCodePlan ?? process.env[BUILD_CODE_PLAN];
  let basPlan = opts?.wsPlan ?? process.env[BAS_PLAN];

  basPlan = basPlan?.toLowerCase().trim();
  buildCodePlan = buildCodePlan?.toLowerCase().trim();

  return (
    ((basPlan === BUILD_CODE_FREE || basPlan === TRIAL) &&
      buildCodePlan === FREE) ||
    (basPlan === BUILD_CODE && buildCodePlan === STANDARD)
  );
}

export function isBuild(opts?: {
  buildCodePlan?: string;
  wsPlan?: string;
}): boolean {
  return isBuildCode(opts) || getBasMode(opts) === BUILD_STANDARD;
}

export async function getTenantMetadata(tenant: {
  landscape: string;
  jwt: string;
}): Promise<{
  buildCodePlan: string;
  wsPlan: string;
  host: string;
}> {
  const { data = {} } = await devUtils.getTenantMetadata(tenant);
  return {
    buildCodePlan: data.buildCodePlan ?? "",
    wsPlan: data.wsPlan ?? "",
    host: data.host ?? "",
  };
}

export function getBasMode(opts?: {
  buildCodePlan?: string;
  wsPlan?: string;
}): BasMode {
  const buildCodePlan = opts?.buildCodePlan ?? process.env[BUILD_CODE_PLAN];
  const basPlan = opts?.wsPlan ?? process.env[BAS_PLAN];
  if (basPlan === BUILD_DEFAULT) {
    return BUILD_STANDARD;
  }
  if (basPlan === FREE) {
    return FREE;
  }
  if (basPlan === TRIAL || basPlan === BUILD_CODE_FREE) {
    if (buildCodePlan === FREE) {
      return BUILD_CODE_FREE_VAL;
    }
    return FREE;
  }
  if (basPlan === BUILD_CODE) {
    if (buildCodePlan === STANDARD) {
      return BUILD_CODE_STANDARD;
    }
  }
  return STANDARD;
}

/**
 * Retrieves the app-external-uri-from-ds based on an internal URI.
 * @param internalUri The internal URI to extract information from.
 * @returns The final URL with the app-external-uri-from-ds encoded.
 */
export function getAppExternalUri(internalUri: string): string {
  if (!internalUri) {
    throw new Error("Internal URI is not provided.");
  }
  // Extract port and path from the internal URI
  const { port, path } = extractPortAndPath(internalUri);

  // Calculate app URL based on port
  const appUrl = calculateAppURLByPort(port);

  // Concatenate appUrl with path
  const appExternalUrl = appUrl + path;

  // Encode the appExternalUrl
  const encodedAppExternalUrl = encodeURIComponent(appExternalUrl);

  // Construct final URL
  const finalUrl = `${getEnvValue(
    ENV_H2O_URL,
  )}/login?e=${encodedAppExternalUrl}`;

  return finalUrl;
}

/**
 * Extracts the port and path from an internal URI.
 * @param internalUri The internal URI.
 * @returns An object containing the port and path.
 */
function extractPortAndPath(internalUri: string): {
  port: number;
  path: string;
} {
  const urlParts = new URL(internalUri);
  const port = parseInt(urlParts.port || "80"); // Default port to 80 if not provided
  // Combine pathname, search, and hash without the initial slash
  const path = urlParts.pathname.slice(1) + urlParts.search + urlParts.hash;
  return { port, path };
}

/* Get workspace URL - should be calculated in the Server
 */

function getWorkspaceUrl(): string {
  return process.env.WS_BASE_URL || "http://localhost:3000/";
}
function isVSCodeHybridEnv(): boolean {
  return process.env.VSCODE_HYBRID === "true";
}

/**  Calculates application URL according to WS_BASE_URL and port
 * @param port
 * @scheme http or https
 * Returns the calculated url ending with '/'
 */
export function calculateAppURLByPort(port: number, scheme = "http"): string {
  let url = "";

  if (isVSCodeHybridEnv()) {
    return `${scheme}://localhost:${port}`;
  }
  try {
    const delimitar = ".";
    const wsUrlStr = getWorkspaceUrl();
    const wsUrl = new URL(wsUrlStr);

    // The URL format is port3000-ws-9qncv.ci10.int.applicationstudio.cloud.sap
    // assume host-based pattern in ws url, as: https://mytenant-wsid/
    // and add port or portssl(when https) prefix to create app url, as: https://port8997-mytenant-wsid/
    const subdomainList: string[] = wsUrl.host.split(delimitar);
    const protocolScheme = scheme === "https" ? "portssl" : "port";
    const appSubdomain = `${protocolScheme}${port}-${subdomainList[0]}`;
    let appHost: string = appSubdomain;
    for (let i = 1; i < subdomainList.length; i++) {
      appHost = appHost + delimitar + subdomainList[i];
    }
    url = `${wsUrl.protocol}//${appHost}/`;
  } catch (e) {
    //we will get here in case of missing protocol or host - new URL throws TypeError [ERR_INVALID_URL]
    url = "";
  }
  return url;
}
export type BasMode =
  | "personal-edition"
  | "standard"
  | "free"
  | "buildCodeFree"
  | "buildCodeStandard"
  | "buildStandard";
