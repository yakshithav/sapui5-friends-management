import urljoin from "url-join";
import { isArray, isPlainObject, isUndefined } from "lodash";
import axios, { AxiosResponse, AxiosRequestConfig } from "axios";
import { getEnvValue } from "../utils/core-utils";
import {
  responseDestinationToDestinationListInfo,
  ResponseDestination,
  DestinationListInfo,
  ENV_H2O_URL,
  getDestinationHeaders,
  AuthenticationType,
  DestinationType,
} from "../utils/destinations";

function getDestinationType(typeName: string): DestinationType | undefined {
  if (typeName !== "HTTP") {
    return undefined;
  }
  return "HTTP";
}

function getAuthenticationType(
  authenticationName: string,
): AuthenticationType | undefined {
  switch (authenticationName) {
    case "NoAuthentication":
      return "NoAuthentication";
    case "BasicAuthentication":
      return "BasicAuthentication";
    case "OAuth2ClientCredentials":
      return "OAuth2ClientCredentials";
    case "OAuth2UserTokenExchange":
      return "OAuth2UserTokenExchange";
    default:
      return undefined;
  }
}
/*
 matchFilter condition:
 All filter's keys should be contained in responseDestination's keys
 and  For each key that exists in the filter, 
 there must be one value from the filter values that matches to responseDestination value according to the key
*/
function matchFilter(
  responseDestination: ResponseDestination,
  filter?: Map<string, string[]>,
): boolean {
  let isMatch = true;
  //if filter is undefined, return true
  if (!filter) {
    return isMatch;
  }
  for (const [key, values] of filter) {
    //reset isMatch
    isMatch = false;
    //if key does not exist in responseDestination return false
    const responseDestinationValue =
      responseDestination[key as keyof ResponseDestination];
    if (!responseDestinationValue) {
      return isMatch;
    }
    for (let i = 0; i < values.length; ++i) {
      //if find one value that match, stop searching for other value in this key
      if (responseDestinationValue === values[i]) {
        isMatch = true;
        break;
      }
    }
    if (!isMatch) {
      return isMatch;
    }
  }
  return isMatch;
}

function isAllowtoAddDestination(
  responseDestination: ResponseDestination,
  filter?: Map<string, string[]>,
): boolean {
  return (
    isPlainObject(responseDestination) &&
    !isUndefined(getDestinationType(responseDestination.Type)) &&
    !isUndefined(getAuthenticationType(responseDestination.Authentication)) &&
    matchFilter(responseDestination, filter)
  );
}

// Transform the response destinations to the real destinations format
function transformToDestinations(
  responseDestinations: ResponseDestination[],
  filter?: Map<string, string[]>,
): DestinationListInfo[] {
  //re-build the destination with the relevant fields
  const destinations: DestinationListInfo[] = [];
  responseDestinations.forEach((responseDestination) => {
    if (isAllowtoAddDestination(responseDestination, filter)) {
      destinations.push(
        responseDestinationToDestinationListInfo(responseDestination),
      );
    }
  });
  return destinations;
}

/**
 * get the destinations list
 */
export async function getDestinations(
  filter?: Map<string, string[]>,
): Promise<DestinationListInfo[] | undefined> {
  const reqURL = urljoin(getEnvValue(ENV_H2O_URL), "/api/listDestinations");
  let resp: AxiosResponse<ResponseDestination[]>;

  try {
    const reqConfig: AxiosRequestConfig = {
      url: reqURL,
      headers: getDestinationHeaders(),
    };

    resp = await axios.request(reqConfig);
  } catch (err) {
    throw new Error(
      `Couldn't retrieve the destination from the (${reqURL}) URL because of the following error: ${err.message}. Error code=${err.response.status}`,
    );
  }

  if (!isArray(resp.data)) {
    throw new Error(`The response data (${resp.data}) is not an array format`);
  }
  return transformToDestinations(resp.data, filter);
}
