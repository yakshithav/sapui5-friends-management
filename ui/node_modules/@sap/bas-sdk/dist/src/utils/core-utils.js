"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtLoginPath = exports.runCommand = exports.getEnvValue = exports.validDevPlatform = exports.isAppStudio = void 0;
const cross_spawn_1 = require("cross-spawn");
const lodash_1 = require("lodash");
/**
 * Return true if the development platform is Buisness Application Studio otherwise return false
 */
function isAppStudio() {
    const wsBaseUrl = process.env.WS_BASE_URL;
    if ((0, lodash_1.isUndefined)(wsBaseUrl)) {
        return false;
    }
    return !(0, lodash_1.isEmpty)(wsBaseUrl);
}
exports.isAppStudio = isAppStudio;
/**
 * Return exception if the development platform is not Buisness Application Studio
 */
function validDevPlatform(funcName) {
    if (!isAppStudio()) {
        throw new Error(`The '${funcName}' API is supported only in Buisness Application Studio environment.`);
    }
}
exports.validDevPlatform = validDevPlatform;
/**
 * Return the value of the given environment variable name
 * @param name - The name of the environment name
 * @returns The value of the environment variable
 * @throws When the environment variable does not exists
 */
function getEnvValue(name) {
    const value = process.env[name];
    if ((0, lodash_1.isUndefined)(value)) {
        throw new Error(`The ${name} environment variable is missing.`);
    }
    return value;
}
exports.getEnvValue = getEnvValue;
async function runCommand(command, args) {
    return new Promise((resolve, reject) => {
        const proc = (0, cross_spawn_1.spawn)(command, args);
        procEvents(command, proc, resolve, reject);
    });
}
exports.runCommand = runCommand;
function procEvents(command, proc, resolve, reject) {
    const output = [];
    let handled = false;
    proc.stdout.on("data", (data) => {
        output.push(String(data));
    });
    proc.stderr.on("data", (data) => {
        output.push(String(data));
    });
    proc.on("error", (err) => {
        // istanbul ignore if - defensive programming, it should not happen
        if (handled) {
            return;
        }
        handled = true;
        reject(err);
    });
    proc.on("exit", (code, signal) => {
        // istanbul ignore if - defensive programming, it should not happen
        if (handled) {
            return;
        }
        handled = true;
        const allOutput = output.join("").trim();
        let returnValue = allOutput.substring(allOutput.lastIndexOf("\n") + 1);
        // If the last line doesn't start with an opening curly brace \"{\", it isn't a JSON object as expected,
        // so instead, all the output is taken.
        // istanbul ignore next - defensive programming, we don't have such a use case currently
        if (!returnValue.startsWith("{")) {
            returnValue = allOutput;
        }
        if (code === 0) {
            resolve(returnValue);
        }
        else {
            // Not using else-if here due to istanbul issue: https://github.com/gotwarlost/istanbul/issues/781
            // istanbul ignore if - signals cannot be triggered easily in tests
            if (signal !== null) {
                const error = new Error(`Could not execute ${command}`);
                error.code = signal;
                reject(error);
            }
            else {
                try {
                    // Tries to get the error message. If no message is found, uses the return value itself.
                    // istanbul ignore next - no easy way to test the condition
                    returnValue = JSON.parse(returnValue).message || returnValue;
                }
                catch (e) {
                    // Ignores this and uses the return value itself.
                }
                reject(new Error(returnValue));
            }
        }
    });
}
/**
 * Compose the url of the 'external login' page according to the specified landscape
 * @param landscapeUrl The url of the required landscape
 * @param useVscodeProtocol - External login process using vscode protocol
 * @returns The calculated value of 'external login' page
 */
function getExtLoginPath(landscapeUrl, useVscodeProtocol) {
    const url = new URL(landscapeUrl);
    url.protocol = `https`;
    url.pathname = `${useVscodeProtocol ? "remote" : "ext"}-login.html`;
    url.search = `cb=${Math.floor(Math.random() * 100000)}`;
    return url.toString();
}
exports.getExtLoginPath = getExtLoginPath;
//# sourceMappingURL=core-utils.js.map