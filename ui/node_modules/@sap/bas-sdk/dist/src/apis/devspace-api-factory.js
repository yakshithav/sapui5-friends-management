"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.devspaceApiFactory = void 0;
const ws_1 = require("ws");
/**
 * Implement the devspace API internally. Expose only the API via the DevspaceApi
 */
class DevspaceApi {
    constructor(devspaceUrl) {
        this.connectionOpen = false;
        this.devspaceUrl = devspaceUrl;
        this.output = "";
        this.prompt = "";
    }
    async connect(jwt) {
        const ret = new Promise((resolve, reject) => {
            const options = {
                headers: { Authorization: `Bearer ${jwt}` },
            };
            this.ws = new ws_1.WebSocket(this.devspaceUrl, options);
            this.ws.on("open", () => {
                this.connectionOpen = true;
                resolve();
            });
            this.ws.on("message", (data) => {
                const value = data.toString();
                // connection can be closed by server side - notify the client
                if (value === "bye!") {
                    this.callback(`${this.output} - connection interrupted...`);
                }
                // each terminal command comes to us in packages, and when we receive the terminal's prompt, we know the command has ended.
                // eslint-disable-next-line no-control-regex -- its a pty terminal's hint symbol pattern, first for Debian terminal (the prompt is '$ ') and second for Alpine terminal (the prompt is `$ [6n`)
                if (/(\$ )$/g.test(value) || /(\$ \[6n)$/g.test(value)) {
                    if (this.prompt) {
                        this.callback(this.output.concat(value.slice(0, -this.prompt.length))); // get rid of the prompt in the value and add it to the output
                        this.output = ""; // clear output buffer
                    }
                    else {
                        // immediately after a connection is established, the terminal first returns a hint character
                        this.prompt = value;
                    }
                }
                else {
                    this.output = this.output.concat(value);
                }
            });
            this.onError((error) => {
                reject(error);
            });
            this.onClose((code, reason) => {
                this.connectionOpen = false;
                console.log(`connection closed ${code}, ${reason}`);
            });
        });
        return ret;
    }
    execute(opt) {
        var _a;
        if (this.connectionOpen) {
            const exec = opt.command.concat(" ", ...(((_a = opt.args) === null || _a === void 0 ? void 0 : _a.join(" ")) || ""), "\n");
            this.ws.send(exec, opt.cb);
        }
    }
    onMessage(v) {
        this.callback = v;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignore for private func
    swapCallback(event, cbName, other) {
        var _a, _b;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignore for private func
        const that = this;
        if (that[cbName]) {
            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.removeListener(event, that[cbName]);
        }
        that[cbName] = other;
        (_b = this.ws) === null || _b === void 0 ? void 0 : _b.addListener(event, that[cbName]);
    }
    onError(callback) {
        this.swapCallback("error", `callbackOnError`, callback);
    }
    onClose(callback) {
        this.swapCallback("close", `callbackOnClose`, callback);
    }
    disconnect() {
        if (this.connectionOpen) {
            this.ws.close();
        }
    }
}
function devspaceApiFactory(devspaceUrl) {
    return new DevspaceApi(devspaceUrl);
}
exports.devspaceApiFactory = devspaceApiFactory;
//# sourceMappingURL=devspace-api-factory.js.map