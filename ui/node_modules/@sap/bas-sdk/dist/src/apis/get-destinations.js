"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDestinations = void 0;
const url_join_1 = __importDefault(require("url-join"));
const lodash_1 = require("lodash");
const axios_1 = __importDefault(require("axios"));
const core_utils_1 = require("../utils/core-utils");
const destinations_1 = require("../utils/destinations");
function getDestinationType(typeName) {
    if (typeName !== "HTTP") {
        return undefined;
    }
    return "HTTP";
}
function getAuthenticationType(authenticationName) {
    switch (authenticationName) {
        case "NoAuthentication":
            return "NoAuthentication";
        case "BasicAuthentication":
            return "BasicAuthentication";
        case "OAuth2ClientCredentials":
            return "OAuth2ClientCredentials";
        case "OAuth2UserTokenExchange":
            return "OAuth2UserTokenExchange";
        default:
            return undefined;
    }
}
/*
 matchFilter condition:
 All filter's keys should be contained in responseDestination's keys
 and  For each key that exists in the filter,
 there must be one value from the filter values that matches to responseDestination value according to the key
*/
function matchFilter(responseDestination, filter) {
    let isMatch = true;
    //if filter is undefined, return true
    if (!filter) {
        return isMatch;
    }
    for (const [key, values] of filter) {
        //reset isMatch
        isMatch = false;
        //if key does not exist in responseDestination return false
        const responseDestinationValue = responseDestination[key];
        if (!responseDestinationValue) {
            return isMatch;
        }
        for (let i = 0; i < values.length; ++i) {
            //if find one value that match, stop searching for other value in this key
            if (responseDestinationValue === values[i]) {
                isMatch = true;
                break;
            }
        }
        if (!isMatch) {
            return isMatch;
        }
    }
    return isMatch;
}
function isAllowtoAddDestination(responseDestination, filter) {
    return ((0, lodash_1.isPlainObject)(responseDestination) &&
        !(0, lodash_1.isUndefined)(getDestinationType(responseDestination.Type)) &&
        !(0, lodash_1.isUndefined)(getAuthenticationType(responseDestination.Authentication)) &&
        matchFilter(responseDestination, filter));
}
// Transform the response destinations to the real destinations format
function transformToDestinations(responseDestinations, filter) {
    //re-build the destination with the relevant fields
    const destinations = [];
    responseDestinations.forEach((responseDestination) => {
        if (isAllowtoAddDestination(responseDestination, filter)) {
            destinations.push((0, destinations_1.responseDestinationToDestinationListInfo)(responseDestination));
        }
    });
    return destinations;
}
/**
 * get the destinations list
 */
async function getDestinations(filter) {
    const reqURL = (0, url_join_1.default)((0, core_utils_1.getEnvValue)(destinations_1.ENV_H2O_URL), "/api/listDestinations");
    let resp;
    try {
        const reqConfig = {
            url: reqURL,
            headers: (0, destinations_1.getDestinationHeaders)(),
        };
        resp = await axios_1.default.request(reqConfig);
    }
    catch (err) {
        throw new Error(`Couldn't retrieve the destination from the (${reqURL}) URL because of the following error: ${err.message}. Error code=${err.response.status}`);
    }
    if (!(0, lodash_1.isArray)(resp.data)) {
        throw new Error(`The response data (${resp.data}) is not an array format`);
    }
    return transformToDestinations(resp.data, filter);
}
exports.getDestinations = getDestinations;
//# sourceMappingURL=get-destinations.js.map